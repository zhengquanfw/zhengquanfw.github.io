<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Knock Knock</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-11-11T16:28:50.414Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Simon Z</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构（3）</title>
    <link href="http://yoursite.com/post/acd66ace.html"/>
    <id>http://yoursite.com/post/acd66ace.html</id>
    <published>2022-11-11T16:27:30.000Z</published>
    <updated>2022-11-11T16:28:50.414Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://s2.loli.net/2022/08/18/xqdTA4wa9QEG5yU.png" alt="image-20220818205734584"></p><h1 id="散列表篇"><a href="#散列表篇" class="headerlink" title="散列表篇"></a>散列表篇</h1><p>在之前，我们已经学习了多种查找数据的方式，比如最简单的，如果数据量不大的情况下，我们可以直接通过顺序查找的方式在集合中搜索我们想要的元素；当数据量较大时，我们可以使用二分搜索来快速找到我们想要的数据，不过需要要求数据按照顺序排列，并且不允许中途对集合进行修改。</p><p>在学习完树形结构篇之后，我们可以利用二叉查找树来建立一个便于我们查找的树形结构，甚至可以将其优化为平衡二叉树或是红黑树来进一步提升稳定性。在最后我们还了解了B树和B+树，得益于它们的巧妙设计，我们可以以尽可能少的时间快速找到我们需要的元素，大大提升程序的运行效率。</p><p>这些都能够极大地帮助我们查找数据，而散列表，则是我们查找系列内容的最后一块重要知识。</p><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><p>我们之前认识的查找算法，最快可以达到对数阶 $O(logN)$，那么我们能否追求极致，让查找性能突破到常数阶呢？这里就要介绍到我们的<strong>散列</strong>（也可以叫哈希 Hash）它采用直接寻址的方式，在理想情况下，查找的时间复杂度可以达到常数阶 $O(1)$。</p><p>散列（Hashing）通过散列函数（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表），也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了：</p><p><img src="https://s2.loli.net/2022/08/18/Tcj6Spy2Pt5ZIuW.png" alt="image-20220818214145347"></p><p>当然，如果一脸懵逼没关系，我们从哈希函数开始慢慢介绍。</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数也叫哈希函数，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后，会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看：</p><p><img src="https://s2.loli.net/2022/08/18/tD8AjiGwvJkdahE.png" alt="image-20220818214908458"></p><p>点进去之后，得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf *ideaIU-2022.2.1.dmg</span><br></pre></td></tr></table></figure><p>这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢？我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。</p><p>可见，哈希函数在这些地方就显得非常实用，在我们的生活中起了很大的作用，它也可以用于布隆过滤器和负载均衡等场景，这里不多做介绍了。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>前面我们介绍了散列函数，我们知道可以通过散列函数计算一个目标的哈希值，那么这个哈希值计算出来有什么用呢，对我们的程序设计有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构，这种表结构是专为哈希设立的，我们称其为哈希表（散列表）</p><p><img src="https://s2.loli.net/2022/08/18/M2o1vE7hHasN8DP.png" alt="image-20220818220944783"></p><p>我们可以将这些元素保存到哈希表中，而保存的位置则与其对应的哈希值有关，哈希值是通过哈希函数计算得到的，我们只需要将对应元素的关键字（一般是整数）提供给哈希函数就可以进行计算了，一般比较简单的哈希函数就是取模操作，哈希表长度是多少（长度最好是一个素数），模就是多少：</p><p><img src="https://s2.loli.net/2022/08/19/CAPhlJnQeLjMHfd.png" alt="image-20220819170355221"></p><p>比如现在我们需要插入一个新的元素（关键字为17）到哈希表中：</p><p><img src="https://s2.loli.net/2022/08/19/ovieRjrzlXhKMC2.png" alt="image-20220819171430332"></p><p>插入的位置为计算出来的哈希值，比如上面是8，那么就在下标位置8插入元素，同样的，我们继续插入27：</p><p><img src="https://s2.loli.net/2022/08/19/pisuSAIZyf5JE7B.png" alt="image-20220819210336314"></p><p>这样，我们就可以将多种多样的数据保存到哈希表中了，注意保存的数据是无序的，因为我们也不清楚计算完哈希值最后会放到哪个位置。那么如果现在我们想要从哈希表中查找数据呢？比如我们现在需要查找哈希表中是否有14这个元素：</p><p><img src="https://s2.loli.net/2022/08/19/H1hAvQPjNui2RYt.png" alt="image-20220819211656628"></p><p>同样的，直接去看哈希值对应位置上看看有没有这个元素，如果没有，那么就说明哈希表中没有这个元素。可以看到，哈希表在查找时只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。</p><p>我们可以通过代码来实现一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Element</span> &#123;</span>   <span class="comment">//这里用一个Element将值包装一下</span></span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">//这里元素设定为int</span></span><br><span class="line">&#125; * E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>&#123;</span>   <span class="comment">//这里把数组封装为一个哈希表</span></span><br><span class="line">    E * table;</span><br><span class="line">&#125; * HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span>&#123;   <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">return</span> key % SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(HashTable hashTable)</span>&#123;   <span class="comment">//初始化函数</span></span><br><span class="line">    hashTable-&gt;table = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Element) * SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">        hashTable-&gt;table[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable hashTable, E element)</span>&#123;   <span class="comment">//插入操作，为了方便就不考虑装满的情况了</span></span><br><span class="line">    <span class="type">int</span> hashCode = hash(element-&gt;key);   <span class="comment">//首先计算元素的哈希值</span></span><br><span class="line">    hashTable-&gt;table[hashCode] = element;   <span class="comment">//对号入座</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">find</span><span class="params">(HashTable hashTable, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);   <span class="comment">//首先计算元素的哈希值</span></span><br><span class="line">    <span class="keyword">if</span>(!hashTable-&gt;table[hashCode]) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果为NULL那就说明没有</span></span><br><span class="line">    <span class="keyword">return</span> hashTable-&gt;table[hashCode]-&gt;key == key;  <span class="comment">//如果有，直接看是不是就完事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">create</span><span class="params">(<span class="type">int</span> key)</span>&#123;    <span class="comment">//创建一个新的元素</span></span><br><span class="line">    E e = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Element));</span><br><span class="line">    e-&gt;key = key;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">hashTable</span>;</span></span><br><span class="line">    init(&amp;hashTable);</span><br><span class="line">    insert(&amp;hashTable, create(<span class="number">10</span>));</span><br><span class="line">    insert(&amp;hashTable, create(<span class="number">7</span>));</span><br><span class="line">    insert(&amp;hashTable, create(<span class="number">13</span>));</span><br><span class="line">    insert(&amp;hashTable, create(<span class="number">29</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;hashTable, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;hashTable, <span class="number">13</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了一个简单的哈希表和哈希函数，通过哈希表，我们可以将数据的查找时间复杂度提升到常数阶。</p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>前面我介绍了哈希函数，通过哈希函数计算得到一个目标的哈希值，但是在某些情况下，哈希值可能会出现相同的情况：</p><p><img src="https://s2.loli.net/2022/08/19/XqpZd1YP5ulEJRy.png" alt="image-20220819215004653"></p><p>比如现在同时插入14和23这两个元素，他们两个计算出来的哈希值是一样的，都需要在5号下标位置插入，这时就出现了打架的情况，那么到底是把哪一个放进去呢？这种情况，我们称为<strong>哈希碰撞</strong>（哈希冲突）</p><p>这种问题是很严重的，因为哈希函数的设计不同，难免会出现这种情况，这种情况是不可避免的，我们只能通过使用更加高级的哈希函数来尽可能避免这种情况，但是无法完全避免。当然，如果要完全解决这种问题，我们还需要去寻找更好的方法。</p><h3 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a>线性探测法</h3><p>既然有可能出现哈希值重复的情况，那么我们可以选择退让，不去进行争抢（忍一时风平浪静，退一步海阔天空）我们可以去找找哈希表中相邻的位置上有没有为空的，只要哈希表没装满，那么我们肯定是可以找到位置装下这个元素的，这种类型的解决方案我们统称为<strong>线性探测法</strong>，开放定址法包含，线性探测法、平方探测法、双散列法等，这里我们以线性探测法为例。</p><p>既然第一次发生了哈希冲突，那么我们就继续去找下一个空位：<br>$$<br>h_i(key) &#x3D; (h(key) + d_i)\space % \space TableSize<br>$$<br>其中 $d_i$ 是随着哈希冲突次数增加随之增加的量，比如上面出现了一次哈希冲突，那么我就将其变成<code>1</code>表示发生了一次哈希冲突，然后我们可以继续去寻找下一个位置：</p><p><img src="https://s2.loli.net/2022/08/20/p5Qdni31eqFgzZ7.png" alt="image-20220820112822005"></p><p>出现哈希冲突时，$d_i$自增，继续寻找下一个空位：</p><p><img src="https://s2.loli.net/2022/08/20/Ay6zkgivEFLthM8.png" alt="image-20220820113020326"></p><p>再次计算哈希值，成功得到对应的位置，注意 $d_i$ 默认为0，这样我们就可以解决冲突的情况了。</p><p>我们来通过代码实际使用一下，这里需要调整一下插入和查找操作的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable hashTable, E element)</span>&#123;   <span class="comment">//插入操作，注意没考虑满的情况，各位小伙伴可以自己实现一下</span></span><br><span class="line">    <span class="type">int</span> hashCode = hash(element-&gt;key), count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (hashTable-&gt;table[hashCode]) &#123;   <span class="comment">//如果发现哈希冲突，那么需要继续寻找</span></span><br><span class="line">        hashCode = hash(element-&gt;key + ++count);</span><br><span class="line">    &#125;</span><br><span class="line">    hashTable-&gt;table[hashCode] = element;   <span class="comment">//对号入座</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">find</span><span class="params">(HashTable hashTable, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key), count = <span class="number">0</span>;   <span class="comment">//首先计算元素的哈希值</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> startIndex = hashCode;   <span class="comment">//记录一下起始位置，要是转一圈回来了得停</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(hashTable-&gt;table[hashCode]-&gt;key == key) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//如果找到就返回1</span></span><br><span class="line">        hashCode = hash(key + ++count);</span><br><span class="line">    &#125; <span class="keyword">while</span> (startIndex != hashCode &amp;&amp; hashTable-&gt;table[hashCode]);  <span class="comment">//没找到继续找</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当出现哈希冲突时，会自动寻找补位插入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">hashTable</span>;</span></span><br><span class="line">    init(&amp;hashTable);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        insert(&amp;hashTable, create(i * <span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, hashTable.table[i]-&gt;key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果采用这种方案删除会比较麻烦，因为有些元素可能是通过线性探测补到其他位置上的，如果删除元素，那么很有可能会影响到前面的查找操作：</p><p><img src="https://s2.loli.net/2022/08/20/PJIVAUnhT6OwB9d.png" alt="image-20220820211324957"></p><p>此时删除关键字为45的元素，会出现截断的情况，当下次查找时，会出现严重问题：</p><p><img src="https://s2.loli.net/2022/08/20/am6WHpejxtyU842.png" alt="image-20220820214945139"></p><p>可以看到，删除一个元素可能会导致原有的结构意外截断，无法正确找到对应的元素，所以，我们在删除元素时，为了防止出现这种截断的情况，我们需要对这个位置进行标记，表示之前有过元素，但是被删除了，当我们在查找时，如果发现曾经有过元素，依然需要继续向后寻找：</p><p><img src="https://s2.loli.net/2022/08/20/hIBUbKvDjAfYruL.png" alt="image-20220820215613368"></p><p>代码实现有点麻烦，这里就不编写代码了。</p><p>当然除了直接向后进行探测之外，我们也可以采用<strong>二次探测再散列法</strong>处理哈希冲突，因为有些时候可能刚好后面没有空位了，但是前面有，如果按照之前的方法，我们得转一圈回来才能找到对应的位置，实在是有点浪费时间，所以说我们可以左右开弓，同时向两个方向去寻找。</p><p>它的查找增量序列为：$1^2$、$-1^2$、$2^2$、$-2^2$、…、$q^2$、$-q^2$，其中$q &lt;&#x3D; \lfloor {TableSize\div2} \rfloor$，比如现在我们要向下面的哈希表中插入数据，现在插入关键字为24的元素，发现冲突了：</p><p><img src="https://s2.loli.net/2022/08/21/CTEFJVNmf47B3yq.png" alt="image-20220821214600725"></p><p>那么此时就需要进行处理了，这里我们采用上面的方式，先去寻找 $1^2$ 位置：</p><p><img src="https://s2.loli.net/2022/08/21/QmiDsrnZjX8YUb6.png" alt="image-20220821214751809"></p><p>我们接着来插入：</p><p><img src="https://s2.loli.net/2022/08/21/Wj9wYLPovF6pAOs.png" alt="image-20220821215445041"></p><p>实际上我们发现和之前是一样的，只要冲突就一直往下找就完事，只不过现在是左右横跳着找，这样可以进一步提升利用率。</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p>实际上常见的哈希冲突解决方案是<strong>链地址法</strong>，当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式：</p><p>![image-20220820220237535](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220820220237535.png)</p><p>当表中元素变多时，差不多就变成了这样，我们一般将其横过来看：</p><p>![image-20220820221104298](&#x2F;Users&#x2F;nagocoler&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220820221104298.png)</p><p>通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，因为现在有了链表，我们得挨个往后看才能找到，当链表变得很长时，查找效率也会变低，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。</p><p>我们来编写代码尝试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span>   <span class="comment">//结点定义</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>&#123;</span>   <span class="comment">//哈希表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">table</span>;</span>   <span class="comment">//这个数组专门保存头结点</span></span><br><span class="line">&#125; * HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(HashTable hashTable)</span>&#123;</span><br><span class="line">    hashTable-&gt;table = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode) * SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        hashTable-&gt;table[i].key = <span class="number">-1</span>;   <span class="comment">//将头结点key置为-1，next指向NULL</span></span><br><span class="line">        hashTable-&gt;table[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">table</span>;</span>    <span class="comment">//创建哈希表</span></span><br><span class="line">    init(&amp;table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是编写对应的插入操作，插入后直接往链表后面丢就完事了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span>&#123;   <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">return</span> key % SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> key)</span>&#123;   <span class="comment">//创建结点专用函数</span></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable hashTable, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);</span><br><span class="line">    Node head = hashTable-&gt;table + hashCode;   <span class="comment">//先计算哈希值，找到位置后直接往链表后面插入结点就完事了</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) head = head-&gt;next;</span><br><span class="line">    head-&gt;next = createNode(key);   <span class="comment">//插入新的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，查找的话也是直接找到对应位置，看看链表里面有没有就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">find</span><span class="params">(HashTable hashTable, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);</span><br><span class="line">    Node head = hashTable-&gt;table + hashCode;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next &amp;&amp; head-&gt;key != key)   <span class="comment">//直到最后或是找到为止</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;key == key;   <span class="comment">//直接返回是否找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">table</span>;</span></span><br><span class="line">    init(&amp;table);</span><br><span class="line"></span><br><span class="line">    insert(&amp;table, <span class="number">10</span>);</span><br><span class="line">    insert(&amp;table, <span class="number">19</span>);</span><br><span class="line">    insert(&amp;table, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;table, <span class="number">20</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;table, <span class="number">17</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, find(&amp;table, <span class="number">19</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这种方案代码写起来也会更简单，使用也更方便一些。</p><p><strong>散列表习题：</strong></p><ol><li><p>下面关于哈希查找的说法，正确的是（ ）</p><p>A 哈希函数构造的越复杂越好，因为这样随机性好，冲突小</p><p>B 除留余数法是所有哈希函数中最好的</p><p>C 不存在特别好与坏的哈希函数，要视情况而定</p><p>D 越简单的哈希函数越容易出现冲突，是最坏的</p><p><em>首先，衡量哈希函数好坏并没有一个确切的标准，而是需要根据具体情况而定，并不一定复杂的哈希函数就好，因为会带来时间上的损失。其实我们的生活中很多东西都像这样，没有好坏之分，只有适不适合的说法，所以说选择C选项</em></p></li><li><p>设有一组记录的关键字为{19，14，23，1，68，20，84，27，55，11，10，79}，用链地址法构造散列表，散列函数为H（key）&#x3D;key MOD 13,散列地址为1的链中有（ ）个记录。</p><p>A 1             B 2               C 3                 D 4</p><p><em>这种咱们得画图才知道了，答案是D</em></p></li><li><p>设哈希表长为14，哈希函数是H(key)&#x3D;key%11，表中已有数据的关键字为15，38，61，84共四个，现要将关键字为49的元素加到表中，用二次探测再散列解决冲突，则放入的位置是（ ）</p><p>A 8             B 3               C 5                 D 9</p><p><em>咱们先把这个表给画出来吧，答案是D</em></p></li><li><p>选取哈希函数 H(key)&#x3D;(key x 3)%11 用线性探测散列法和二次探测再散列法分别处理冲突。试在0~10的散列地址空间中，对关键字序列（22,41,53,46,30,13,1,67）构建哈希表，并求等概率情况下查找成功的平均查找长度。</p><p><em>其中平均查找长度（ASL）就是表中每一个元素需要查找次数之和的平均值，我们注意在插入元素时顺便记录计算次数即可，如果是链地址法，那么直接看层数就行，ASL &#x3D;（第一层结点数量+第二层结点数量+第三层结点数量）&#x2F; 非头结点总数</em></p></li></ol><h2 id="算法实战"><a href="#算法实战" class="headerlink" title="算法实战"></a>算法实战</h2><h3 id="（简单）两数之和"><a href="#（简单）两数之和" class="headerlink" title="（简单）两数之和"></a>（简单）两数之和</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/two-sum/">1.两数之和</a>（整个力扣的第一题）</p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p> 示例 1：</p><blockquote><p>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums &#x3D; [3,2,4], target &#x3D; 6<br>输出：[1,2]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums &#x3D; [3,3], target &#x3D; 6<br>输出：[0,1]</p></blockquote><p>这道题很简单，实际上使用暴力枚举是可以完成的，我们只需要让每个数去寻找一个与其匹配的数即可，所以说直接循环就完事：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">result</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> * returnSize)</span>&#123;</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> * result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    result[<span class="number">0</span>] = i;</span><br><span class="line">    result[<span class="number">1</span>] = j;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numsSize; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target) </span><br><span class="line">                <span class="keyword">return</span> result(i, j, returnSize);   <span class="comment">//找到匹配就直接返回完事</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//无视即可，因为不可能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样效率实在是太低了，可以看到我们的程序运行时间都好几百毫秒了，能不能优化一下呢？我们正好学习了散列表，是否可以利用一下散列表来帮助我们完成？</p><p>因为每当我们遍历一个数时，实际上就是去寻找与其匹配的数是否存在，我们可以每遍历一个数都将其存放到散列表中，当下次遇到与其相匹配的数时，只要能够从散列表中找到这个数，那么就可以直接完成匹配了，这样就只需要遍历一次即可完成。比如：</p><blockquote><p>[2,7,11,15] ，targert &#x3D; 9</p><p>第一次先将2放入散列表，接着往后看7，现在目标值时9，那么只需要去寻找 9 - 7 这个数，看看散列表中有没有即可，此时散列表中正好有2，所以说直接返回即可。</p></blockquote><p>我们来尝试编写一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> K;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> V;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span>   <span class="comment">//结点定义需要稍微修改一下，因为除了存关键字还需要存一下下标</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span>&#123;</span>   <span class="comment">//哈希表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">table</span>;</span>   <span class="comment">//这个数组专门保存头结点</span></span><br><span class="line">&#125; * HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(HashTable hashTable)</span>&#123;</span><br><span class="line">    hashTable-&gt;table = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode) * SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) &#123;</span><br><span class="line">        hashTable-&gt;table[i].key = <span class="number">-1</span>;   <span class="comment">//将头结点key置为-1，value也变成-1，next指向NULL</span></span><br><span class="line">        hashTable-&gt;table[i].value = <span class="number">-1</span>;</span><br><span class="line">        hashTable-&gt;table[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> key)</span>&#123;  <span class="comment">//因为哈希表用的数组，要是遇到负数的key，肯定不行，咱先给它把符号扬了再算</span></span><br><span class="line">    <span class="keyword">return</span> key % SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">create</span><span class="params">(K key, V value)</span>&#123;   <span class="comment">//创建结点，跟之前差不多</span></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable hashTable, K key, V value)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);</span><br><span class="line">    Node head = hashTable-&gt;table + hashCode;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) head = head-&gt;next;</span><br><span class="line">    head-&gt;next = create(key, value);   <span class="comment">//这里同时保存关键字和对应的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">find</span><span class="params">(HashTable hashTable, K key)</span>&#123;</span><br><span class="line">    <span class="type">int</span> hashCode = hash(key);</span><br><span class="line">    Node head = hashTable-&gt;table + hashCode;     <span class="comment">//直接定位到对应位置</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next &amp;&amp; head-&gt;next-&gt;key != key)   <span class="comment">//直接看有没有下一个结点，并且下一个结点不是key</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">//继续往后找</span></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;   <span class="comment">//出来之后要么到头了下一个是NULL，要么就是找到了，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希表编写完成后，我们就可以使用了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">result</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> * returnSize)</span>&#123;   <span class="comment">//跟上面一样</span></span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> * result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">2</span>);</span><br><span class="line">    result[<span class="number">0</span>] = i;</span><br><span class="line">    result[<span class="number">1</span>] = j;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HashTable</span> <span class="title">table</span>;</span>    <span class="comment">//初始化哈希表</span></span><br><span class="line">    init(&amp;table);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; ++i) &#123;   <span class="comment">//挨个遍历</span></span><br><span class="line">        Node node = find(&amp;table, target - nums[i]);  <span class="comment">//直接去哈希表里面寻找匹配的，如果有直接结束，没有就丢把当前的key丢进哈希表，之后如果遇到与其匹配的另一半，那么就直接成功了</span></span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">NULL</span>) <span class="keyword">return</span> result(i, node-&gt;value, returnSize);</span><br><span class="line">        insert(&amp;table, nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//无视就好</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次提交代码，时间直接来到了个位数：</p><p><img src="https://s2.loli.net/2022/08/21/pGF2hZo5ArbLyfB.png" alt="image-20220821122010425"></p><p>采用哈希表，就是一种空间换时间的策略，在大多数情况下，我们也更推荐使用这种方案。</p><p>此文章为搬运！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构（2）</title>
    <link href="http://yoursite.com/post/146a0dab.html"/>
    <id>http://yoursite.com/post/146a0dab.html</id>
    <published>2022-11-11T16:25:17.000Z</published>
    <updated>2022-11-11T16:26:53.595Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="树形结构篇"><a href="#树形结构篇" class="headerlink" title="树形结构篇"></a>树形结构篇</h1><p>前面我们学习了线性相关的数据结构，了解了顺序表和链表两种类型，我们接着来看树形结构。这一章会更加考验各位小伙伴的数学功底以及逻辑思维，难度会更大一些。</p><h2 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h2><p>树是一种全新的数据结构，它就像一棵树的树枝一样，不断延伸。</p><p><img src="https://s2.loli.net/2022/08/08/NajFZzXHxUCDQBW.png" alt="image-20220808151202634"></p><h3 id="树结构介绍"><a href="#树结构介绍" class="headerlink" title="树结构介绍"></a>树结构介绍</h3><p>一棵树就像下面这样连接：</p><p><img src="https://s2.loli.net/2022/08/01/aoBjrR5bPqWzCel.png" alt="image-20220801210920230"></p><p>可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为<strong>树</strong>（Tree）注意分支只能向后单独延伸，之后就分道扬镳了，<strong>不能与其他分支上的结点相交！</strong></p><ul><li>我们一般称位于最上方的结点为树的<strong>根结点</strong>（Root）因为整棵树正是从这里开始延伸出去的。</li><li>每个结点连接的子结点数目（分支的数目），我们称为结点的<strong>度</strong>（Degree），而各个结点度的最大值称为树的度。</li><li>每个结点延伸下去的下一个结点都可以称为一棵<strong>子树</strong>（SubTree）比如结点<code>B</code>及其之后延伸的所有分支合在一起，就是一棵<code>A</code>的子树。</li><li>每个<strong>结点的层次</strong>（Level）按照从上往下的顺序，树的根结点为<code>1</code>，每向下一层<code>+1</code>，比如<code>G</code>的层次就是<code>3</code>，整棵树中所有结点的最大层次，就是这颗<strong>树的深度</strong>（Depth），比如上面这棵树的深度为4，因为最大层次就是4。</li></ul><p>由于整棵树错综复杂，所以说我们需要先规定一下结点之间的称呼，就像族谱那样：</p><ul><li>与当前结点直接向下相连的结点，我们称为<strong>子结点</strong>（Child），比如<code>B、C、D</code>结点，都是<code>A</code>的子结点，就像族谱中的父子关系一样，下一代一定是子女，相反的，那么<code>A</code>就是<code>B、C、D</code>的<strong>父结点</strong>（Parent），也可以叫双亲结点。</li><li>如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为<strong>叶子结点</strong>（因为已经到头了，后面没有分支了，这时就该树枝上长叶子了那样）比如<code>K、L、F、G、M、I、J</code>结点，都是叶子结点。</li><li>如果两个结点的父结点是同一个，那么称这两个节点为<strong>兄弟结点</strong>（Sibling）比如<code>B</code>和<code>C</code>就是兄弟结点，因为都是<code>A</code>的孩子。</li><li>从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的<strong>祖先结点</strong>（Ancestor）比如<code>L</code>的祖先结点就是<code>A、B、E</code></li></ul><p>那么在了解了树的相关称呼之后，相信各位就应该对树有了一定的了解，虽然概念比较多，但是还请各位一定记住，不然后面就容易听懵。</p><h3 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h3><p>森林其实很好理解，一片森林肯定是是由很多棵树构成的，比如下面的三棵树：</p><p><img src="https://s2.loli.net/2022/08/01/VnblyMgQXkC6cBu.png" alt="image-20220801222928422"></p><p>它们共同组成了一片森林，因此，m（m≥0）棵树的集合我们称为<strong>森林</strong>（Forest）</p><hr><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>前面我们给大家介绍了树的概念，而我们本章需要着重讨论的是<strong>二叉树</strong>（Binary Tree）它是一种特殊的树，它的度最大只能为<code>2</code>，所以我们称其为二叉树，一棵二叉树大概长这样：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>并且二叉树任何结点的子树是有左右之分的，不能颠倒顺序，比如A结点左边的子树，称为左子树，右边的子树称为右子树。</p><p>二叉树有5种基本形态，分别是：</p><p><img src="https://s2.loli.net/2022/08/01/8ncvzo6aLem14ju.png" alt="image-20220801224513856"></p><p>当然，对于某些二叉树我们有特别的称呼，比如，在一棵二叉树中，所有分支结点都存在左子树和右子树，且叶子结点都在同一层：</p><p><img src="https://s2.loli.net/2022/08/01/btfjlJhDuWrSXYi.png" alt="image-20220801231216578"></p><p>这样的二叉树我们称为<strong>满二叉树</strong>，可以看到整棵树都是很饱满的，没有出现任何度为1的结点，当然，还有一种特殊情况：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>可以看到只有最后一层有空缺，并且所有的叶子结点是按照从左往右的顺序排列的，这样的二叉树我们一般称其为<strong>完全二叉树</strong>，所以，一棵满二叉树，一定是一棵完全二叉树。</p><h3 id="树和森林的转换"><a href="#树和森林的转换" class="headerlink" title="树和森林的转换"></a>树和森林的转换</h3><p>二叉树和树、森林之间是可以相互转换的。</p><p>我们可以使用下面的规律将一棵普通的树转换为一棵二叉树：</p><ol><li>最左边孩子结点 -&gt; 左子树结点（左孩子）</li><li>兄弟结点 -&gt; 右子树结点（右孩子）</li></ol><p>我们以下面的这棵树为例：</p><p><img src="https://s2.loli.net/2022/08/06/y51pTzhrQV3GPCJ.png" alt="image-20220806101322807"></p><p>我们优先从左边开始看，B、F、G都是A的子结点，根据上面的规律，我们将B作为左子树：</p><p><img src="https://s2.loli.net/2022/08/06/g4XfmiQHaOy6JhG.png" alt="image-20220806101841459"></p><p>接着继续从左往右看，由于F是B的兄弟结点，那么根据规律，F作为B的右子树：</p><p><img src="https://s2.loli.net/2022/08/06/6wqO4iErjQpyKzP.png" alt="image-20220806102023764"></p><p>接着是G，G是F的兄弟结点，那么G继续作为F的右子树：</p><p><img src="https://s2.loli.net/2022/08/06/DfBsxVHlSotn6I3.png" alt="image-20220806102123476"></p><p>我们接着来看第三排，依然是从左往右，C是B的子节点，所以C作为B的左子树：</p><p><img src="https://s2.loli.net/2022/08/06/93zFJGyx2SBLHC4.png" alt="image-20220806102501769"></p><p>接着，D是C的兄弟节点，那么D就作为C的右子树了：</p><p><img src="https://s2.loli.net/2022/08/06/YO5zf2TVHqBdnX6.png" alt="image-20220806102619705"></p><p>此时还有一个H结点，它是G的子结点，所以直接作为G的左子树：</p><p><img src="https://s2.loli.net/2022/08/06/oHcAM6d2SFrveaE.png" alt="image-20220806102802036"></p><p>现在只剩下最后一排了，E是D的子结点，K是H的子结点，所以最后就像这样了：</p><p><img src="https://s2.loli.net/2022/08/06/6JxYP2CXSyZdGa4.png" alt="image-20220806102932517"></p><p>按照规律，我们就将一棵树转换为了二叉树。当然还有一种更简单的方法，我们可以直接将所有的兄弟结点连起来（橙色横线）：</p><p><img src="https://s2.loli.net/2022/08/07/OSZ71J6CVEzeNiW.png" alt="image-20220807231603707"></p><p>接着擦掉所有结点除了最左边结点以外的连线：</p><p><img src="https://s2.loli.net/2022/08/07/y62Z3UlaWdemI7v.png" alt="image-20220807231704465"></p><p>所有的黑色连线偏向左边，橙色连线偏向右边：</p><p><img src="https://s2.loli.net/2022/08/07/yzA2uLqhYDnbZcJ.png" alt="image-20220807231922091"></p><p>效果是一样的，这两种方式都可以，你觉得哪一种简单就使用哪一种就行了。我们会发现，无论一棵树长成啥样，转换为二叉树后，<strong>根节点一定没有右子树</strong>。</p><p><strong>思考：</strong>那二叉树咋变回普通的树呢？实际上我们只需要反推回去就行了。</p><p>那么森林呢，森林如何转换为一棵二叉树呢？其实很简单：</p><p><img src="https://s2.loli.net/2022/08/08/QCIaYTcEv2NO47G.png" alt="image-20220808113135783"></p><p>首先我们还是按照二叉树转换为树的规则，将森林中所有树转换为二叉树，接着我们只需要依次连接即可：</p><p><img src="https://s2.loli.net/2022/08/08/O3xnhv85WLPzJpq.png" alt="image-20220808113251636"></p><p>注意连接每一棵树的时候，一律从根结点的右边开始，不断向右连接。</p><p>我们发现，相比树转换为二叉树，森林转换为二叉树之后，根节点就存在右子树了，右子树连接的都是森林中其他的树。</p><p><strong>思考：</strong>现在有一棵二叉树，我们想要转回去，我们怎么知道到底是将其转换为森林还是转换为树呢？</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>由于二叉树结构特殊，我们可以总结出以下的五个性质：</p><ul><li><p><strong>性质一：</strong>对于一棵二叉树，第<code>i</code>层的最大结点数量为 $2^{i-1}$ 个，比如二叉树的第一层只有一个根结点，也就是 $2^0 &#x3D; 1$ ，而二叉树的第三层可以有 $2^2 &#x3D; 4$ 个结点。</p></li><li><p><strong>性质二：</strong>对于一棵深度为<code>k</code>的二叉树，可以具有的最大结点数量为：<br>$$<br>n &#x3D; 2^0 + 2^1 + 2^2 + … + 2^{k-1}<br>$$<br>我们发现，实际上每一层的结点数量，组成了一个等比数列，公比<code>q</code>为<code>2</code>，结合等比数列求和公式，我们可以将其简化为：<br>$$<br>S_n &#x3D; \frac {a_1 \times (1 - q^n)} {1 - q} &#x3D; \frac {1 \times (1 - 2^k)} {1 - 2} &#x3D; - (1 - 2^k) &#x3D; 2^k - 1<br>$$<br>所以一棵深度为<code>k</code>的二叉树最大结点数量为 $n &#x3D; 2^k - 1$，顺便得出，结点的边数为 $E &#x3D; n - 1$。</p></li><li><p><strong>性质三：</strong>假设一棵二叉树中度为0、1、2的结点数量分别为$n_0$、$n_1$、$n_2$，由于一棵二叉树中只有这三种类型的结点，那么可以直接得到结点总数：<br>$$<br>n &#x3D; n_0 + n_1 + n_2<br>$$<br>我们不妨换一个思路，我们从二叉树的边数上考虑，因为每个结点有且仅有一条边与其父结点相连，那么边数之和就可以表示为：<br>$$<br>E &#x3D; n_1 + 2n_2<br>$$<br>度为1的结点有一条边，度为2的结点有两条边，度为0的结点没有，加在一起就是整棵二叉树的边数之和，结合我们在<strong>性质二</strong>中推导的结果，可以得到另一种计算结点总数的方式：<br>$$<br>E &#x3D; n - 1 &#x3D; n_1 + 2n_2<br>$$</p><p>$$<br>n &#x3D; n_1 + 2n_2 + 1<br>$$</p><p>再结合我们第一个公式：<br>$$<br>n &#x3D; n_0 + n_1 + n_2 &#x3D; n_1 + 2n_2 + 1<br>$$<br>综上，对于任何一棵二叉树，如果其叶子结点个数为 $n_0$ ，度为2的结点个数为 $n_2$ ，那么两者满足以下公式：<br>$$<br>n_0 &#x3D; n_2 + 1<br>$$<br><em>（性质三的推导过程比较复杂，如果觉得麻烦推荐直接记忆）</em></p></li><li><p><strong>性质四：</strong>完全二叉树除了最后一层有空缺外，其他层数都是饱满的，假设这棵二叉树为满二叉树，那么根据我们前面得到的性质，假设层数为<code>k</code>，那么结点数量为：$n &#x3D; 2^k - 1$ ，根据完全二叉树的性质，最后一层可以满可以不满，那么一棵完全二叉树结点数<code>n</code>满足：<br>$$<br>2^{k-1} - 1 &lt; n &lt;&#x3D; 2^k - 1<br>$$<br>因为<code>n</code>肯定是一个整数，那么可以写为：<br>$$<br>2^{k - 1} &lt;&#x3D; n &lt;&#x3D; 2^k - 1<br>$$<br>现在我们只看左边的不等式，我们对不等式两边同时取对数，得到：<br>$$<br>k - 1 &lt;&#x3D; log_2n<br>$$<br>综上所述，一棵具有<code>n</code>个结点的完全二叉树深度为 $k &#x3D; \lfloor log_2n \rfloor + 1$ 。</p><p><em>（性质四的推导过程比较复杂，如果觉得麻烦推荐直接记忆）</em></p></li><li><p><strong>性质五：</strong>一颗有<code>n</code>个结点的完全二叉树，由性质四得到深度为 $k &#x3D; \lfloor log_2n \rfloor + 1$ 现在对于任意一个结点<code>i</code>，结点的顺序为从上往下，从左往右：</p><ul><li>对于一个拥有左右孩子的结点来说，其左孩子为<code>2i</code>，右孩子为<code>2i + 1</code>。</li><li>如果<code>i = 1</code>，那么此结点为二叉树的根结点，如果<code>i &gt; 1</code>，那么其父结点就是 $\lfloor i&#x2F;2 \rfloor$，比如第3个结点的父结点为第1个节点，也就是根结点。</li><li>如果<code>2i &gt; n</code>，则结点<code>i</code>没有左孩子，比如下面图中的二叉树，n为5，假设此时<code>i = 3</code>，那么<code>2i = 6 &gt; n = 5</code> 说明第三个结点没有左子树。</li><li>如果<code>2i + 1 &gt; n</code>，则结点<code>i</code>没有右孩子。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>以上五条二叉树的性质一般是笔试重点内容，还请务必牢记，如果觉得推导过程比较麻烦，推荐直接记忆结论。</p><p><strong>二叉树练习题：</strong></p><ol><li><p><strong>由三个结点可以构造出多少种不同的二叉树？</strong></p><p><em>这个问题我们可以直接手画得到结果，一共是五种，当然，如果要求N个结点的话，可以利用动态规划求解，如果这道题是求N个结点可以构造多少二叉树，我们可以分析一下：</em></p><ul><li>假设现在只有一个结点或者没有结点，那么只有一种，$h(0) &#x3D; h(1) &#x3D; 1$</li><li>假设现在有两个结点，那么其中一个拿来做根结点，剩下这一个可以左边可以右边，要么左边零个结点右边一个结点，要么左边一个结点右边零个结点，所以说 $h(2) &#x3D; h(1) × h(0) + h(0) × h(1) &#x3D; 2$</li><li>假设现在有三个结点，那么依然是其中一个拿来做根节点，剩下的两个结点情况就多了，要么两个都在左边，两个都在右边，或者一边一个，所以说 $h(3) &#x3D; h(2) × h(0) + h(1) × h(1) + h(0) × h(2)$</li></ul><p><em>我们发现，它是非常有规律的，N每+1，项数多一项，所以我们只需要按照规律把所有情况的结果相加就行了，我们按照上面推导的结果，编写代码：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;size);   <span class="comment">//读取需要求的N</span></span><br><span class="line">    <span class="type">int</span> dp[size + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">1</span>;   <span class="comment">//没有结点或是只有一个结点直接得到1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= size; ++i) &#123;</span><br><span class="line">        dp[i] = <span class="number">0</span>;   <span class="comment">//一开始先等于0再说</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;   <span class="comment">//内层循环是为了计算所有情况，比如i等于3，那么就从j = 0开始，计算dp[0]和dp[2]的结果，再计算dp[1]和dp[1]...</span></span><br><span class="line">            dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[size]);   <span class="comment">//最后计算的结果就是N个结点构造的二叉树数量了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/08/DIHPQcxgbVXLaYK.png" alt="image-20220808121124094"></p><p><em>成功得到结果，当然，实际上我们根据这个规律，还可以将其进一步简化，求出的结果序列为：1, 1, 2, 5, 14, 42, 132…，这种类型的数列我们称为<strong>卡特兰数</strong>，以中国蒙古族数学家明安图 (1692-1763)和比利时的数学家欧仁·查理·卡塔兰 (1814–1894)的名字来命名，它的通项公式为：</em><br>$$<br>C_n &#x3D; \frac {1} {n + 1}C^n_{2n} &#x3D; \frac {1} {n + 1} \times \frac {(2n)!} {n!\times(2n - n)!} &#x3D; \frac {(2n)!} {n!\times (n + 1)!}<br>$$<br><em>所以说不需要动态规划了，直接一个算式解决问题：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) res *= i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, factorial(<span class="number">2</span>*n) / (factorial(n) * factorial(n + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>只不过这里用的是int，运算过程中如果数字太大的话就没办法了</em></p></li><li><p><strong>一棵完全二叉树有1001个结点，其中叶子结点的个数为？</strong></p><p><em>既然是完全二叉树，那么最下面这一排肯定是按顺序排的，并且上面各层应该是排满了的，那么我们先求出层数，根据性质四：</em><br>$$<br>k &#x3D; \lfloor log_2n \rfloor + 1 &#x3D; 9 + 1 &#x3D; 10<br>$$<br><em>所以此二叉树的层数为10，也就是说上面9层都是满满当当的，最后一层不满，那么根据性质二，我们求出前9层的结点数：</em><br>$$<br>n &#x3D; 2^k - 1 &#x3D; 511<br>$$<br><em>那么剩下的结点就都是第十层的了，得到第十层所有叶子结点数量 $ &#x3D; 1001 - 511 &#x3D; 490$，因为第十层并不满，剩下的叶子第九层也有，所以最后我们还需要求出第九层的叶子结点数量，先计算第九层的所有结点数量：</em><br>$$<br>n &#x3D; 2^{i - 1}&#x3D;256<br>$$<br><em>接着我们需要去掉那些第九层度为一和度为二的结点，其实只需要让第十层都叶子结点除以2就行了：</em><br>$$<br>n &#x3D; (490 + 1) &#x2F; 2 &#x3D; 245<br>$$<br><em>注意在除的时候+1，因为有可能会出现一个度为1的结点，此时也需要剔除，所以说+1变成偶数这样才可以正确得到结果。最后剔除这些结点，得到最终结果：</em><br>$$<br>n_0 &#x3D; 256 - 245 + 490 &#x3D; 501<br>$$<br><em>所以这道题的答案为501。</em></p></li><li><p><strong>深度为h的满m叉树的第k层有多少个结点？</strong></p><p><em>这道题只是看着复杂，但是实际上我们把之前推导都公式带进来就行了。但是注意，难点在于，这道题给的是满m叉树，而不是满二叉树，满二叉树根据性质一我们已经知道：</em><br>$$<br>n &#x3D; 2^{i-1}<br>$$<br>那m叉树呢？实际上也是同理的，我们以三叉树为例，每向下一层，就划分三个孩子结点出来：</p><p><img src="https://s2.loli.net/2022/08/08/XvH4At8Q93nkFIR.png" alt="image-20220808131305843"></p><p>每一层的最大结点数依次为：1、3、9、27….</p><p>我们发现，实际上每一层的最大结点数，正好是3的次方，所以说无论多少叉树，实际上变化的就是底数而已，所以说深度为h（h在这里没卵用，障眼法罢了）的满m叉树第k层的结点数：<br>$$<br>n &#x3D; m^{k-1}<br>$$</p></li><li><p><strong>一棵有1025个结点的二叉树的层数k的取值范围是？</strong></p><p><em>这个问题比较简单，层数的最小值实际上就是为完全二叉树的情况，层数的最大值实际上就是连成一根线的情况，结点数就是层数，所以说根据性质四得到最小深度为11，最大深度就直接1025了，k的范围是11 - 1025</em></p></li><li><p><strong>将一棵树转换为二叉树时，根节点的右边连接的是？</strong></p><p><em>根据我们前面总结得到的性质，树转换为二叉树之后，根节点一定没有右子树，所以为空</em></p></li></ol><h3 id="二叉树的构建"><a href="#二叉树的构建" class="headerlink" title="二叉树的构建"></a>二叉树的构建</h3><p>前面我们介绍了二叉树的几个重要性质，那么现在我们就来尝试在程序中表示和使用一棵二叉树。</p><p>二叉树的存储形式也可以使用我们前面的两种方式，一种是使用数组进行存放，还有一种就是使用链式结构，只不过之前链式结构需要强化一下才可以表示为二叉树。</p><p>首先我们来看数组形式的表示方式，利用前面所推导的性质五，我们可以按照以下顺序进行存放：</p><p><img src="https://s2.loli.net/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>这颗二叉树的顺序存储：</p><p><img src="https://s2.loli.net/2022/08/06/jTtvWahxI9VUKuG.png" alt="image-20220806110546789"></p><p>从左往右，编号<code>i</code>从1开始，比如现在我们需要获取A的右孩子，那么就需要根据性质五进行计算，因为右孩子为<code>2i + 1</code>，所以A的右边孩子的编号就是3，也就是结点C。</p><p>这种表示形式使用起来并不方便，而且存在大量的计算，所以说我们只做了解即可，我们的重点是下面的链式存储方式。</p><p>我们在前面使用链表的时候，每个结点不仅存放对应的数据，而且会存放一个指向下一个结点的指针：</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>而二叉树也可以使用这样的链式存储形式，只不过现在一个结点需要存放一个指向左子树的指针和一个指向右子树的指针了：</p><p><img src="https://s2.loli.net/2022/08/06/H9MqkghmAjFJnuO.png" alt="image-20220806111610082"></p><p>通过这种方式，我们就可以通过连接不同的结点形成一颗二叉树了，这样也更便于我们去理解它，我们首先定义一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;    <span class="comment">//存放元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span>   <span class="comment">//指向左子树的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span>   <span class="comment">//指向右子树的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Node</span>;</span></span><br></pre></td></tr></table></figure><p>比如我们现在想要构建一颗像这样的二叉树：</p><p><img src="https://s2.loli.net/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>首先我们需要创建好这几个结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Node a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));   <span class="comment">//依次创建好这五个结点</span></span><br><span class="line">    Node b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node d = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node e = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">  a-&gt;element = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    b-&gt;element = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    c-&gt;element = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    d-&gt;element = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    e-&gt;element = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们从最上面开始，挨着进行连接，首先是A这个结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    a-&gt;left = b;   <span class="comment">//A的左孩子是B</span></span><br><span class="line">    a-&gt;right = c;   <span class="comment">//A的右孩子是C</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是B这个结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    b-&gt;left = d;   <span class="comment">//B的左孩子是D</span></span><br><span class="line">    b-&gt;right = e;   <span class="comment">//B的右孩子是E</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//别忘了把其他的结点改为NULL</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就成功构建好了这棵二叉树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a-&gt;left-&gt;left-&gt;element);   <span class="comment">//比如现在我想要获取A左孩子的左孩子，那么就可以直接left二连</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断点调试也可以看的很清楚：</p><p><img src="https://s2.loli.net/2022/08/06/oTPeUpBlmNsZWE1.png" alt="image-20220806113156166"></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>前面我们通过使用链式结构，成功构建出了一棵二叉树，接着我们来看看如何遍历一棵二叉树，也就是说我们想要访问二叉树的每一个结点，由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：<strong>前序遍历、中序遍历、后序遍历、层序遍历。</strong>不同的访问方式输出都结点顺序也不同。</p><p>首先我们来看最简单的前序遍历：</p><p><img src="https://s2.loli.net/2022/08/06/G6ujstSVZ2XWJLE.png" alt="image-20220806171459056"></p><p>前序遍历是一种勇往直前的态度，走到哪就遍历到那里，先走左边再走右边，比如上面的这个图，首先会从根节点开始：</p><p><img src="https://s2.loli.net/2022/08/06/qCFMosHtujEZ3U6.png" alt="image-20220806171431845"></p><p>从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：ABDECF</p><ol><li>打印根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><p>我们不难发现规律，整棵二叉树（包括子树）的根节点一定是出现在最前面的，比如A在最前面，A的左子树根结点B也是在最前面的。</p><p>接着我们来通过代码实现一下，首先先把咱们这棵二叉树组装好：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Node a = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node b = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node c = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node d = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node e = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    Node f = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    a-&gt;element = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    b-&gt;element = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    c-&gt;element = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    d-&gt;element = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line">    e-&gt;element = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line">    f-&gt;element = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    a-&gt;left = b;</span><br><span class="line">    a-&gt;right = c;</span><br><span class="line">    b-&gt;left = d;</span><br><span class="line">    b-&gt;right = e;</span><br><span class="line">    c-&gt;right = f;</span><br><span class="line">    c-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    d-&gt;left = e-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    e-&gt;left = e-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    f-&gt;left = f-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装好之后，我们来实现一下前序遍历的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;   <span class="comment">//传入的是二叉树的根结点</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在我们拿到根结点之后该怎么去写呢？既然是走到哪里打印到哪里，那么我们就先打印一下当前结点的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//不多bb先打印再说</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印完成之后，我们就按照先左后右的规则往后遍历下一个结点，这里我们就直接使用递归来完成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);</span><br><span class="line">    preOrder(root-&gt;left);   <span class="comment">//将左孩子结点递归交给下一级</span></span><br><span class="line">    preOrder(root-&gt;right);  <span class="comment">//等上面的一系列向左递归结束后，再以同样的方式去到右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过还没，我们的递归肯定是需要一个终止条件的，不可能无限地进行下去，如果已经走到底了，那么就不能再往下走了，所以：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;   <span class="comment">//如果走到NULL了，那就表示已经到头了，直接返回</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);</span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">    preOrder(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果为：</p><p><img src="https://s2.loli.net/2022/08/06/hZ8qEfWaP5o6L2j.png" alt="image-20220806173227580"></p><p>这样我们就通过一个简单的递归操作完成了对一棵二叉树的前序遍历，如果不太好理解，建议结合调试进行观察。</p><p>当然也有非递归的写法，我们使用循环，但是就比较麻烦了，我们需要使用栈来帮助我们完成（实际上递归写法本质上也是在利用栈），我们依然是从第一个结点开始，先走左边，每向下走一步，先输出节点的值，然后将对应的结点丢到栈中，当走到尽头时，表示左子树已经遍历完成，接着就是从栈中依次取出栈顶节点，如果栈顶结点有右子树，那么再按照同样的方式遍历其右子树，重复执行上述操作，直到栈清空为止。</p><ul><li>一路向左，不断入栈，直到尽头</li><li>到达尽头后，出栈，看看有没有右子树，如果没有就继续出栈，直到遇到有右子树的为止</li><li>拿到右子树后，从右子树开始，重复上述步骤，直到栈清空</li></ul><p>比如我们还是以上面的这棵树为例：</p><p><img src="https://s2.loli.net/2022/08/06/G6ujstSVZ2XWJLE.png" alt="image-20220806171459056"></p><p>首先我们依然从根结点A出发，不断遍历左子树，沿途打印结果并将节点丢进栈中：</p><p><img src="https://s2.loli.net/2022/08/06/e1Nf5WhQdY9VGOD.png" alt="image-20220806215229564"></p><p>当遍历到D结点时，没有左子树了，此时将栈顶结点D出栈，发现没有右节点，继续出栈，得到B结点，接着得到当前结点的右孩子E结点，然后重复上述步骤：</p><p><img src="https://s2.loli.net/2022/08/06/pZ6FRWn9wNg1JhY.png" alt="image-20220806220752941"></p><p>接着发现E也没有左子树了，同样的，又开始出栈，此时E没有右子树，接着看A，A有右子树，所以继续从C开始，重复上述步骤：</p><p><img src="https://s2.loli.net/2022/08/06/K73cGsRUP6WO5iu.png" alt="image-20220806221147022"></p><p>由于C之后没有左子树，那么就出栈获取右子树，此时得到结点F，继续重复上述步骤：</p><p><img src="https://s2.loli.net/2022/08/06/zkZisVY9H2qAafL.png" alt="image-20220806221239705"></p><p>最后F出栈，没有右子树了，栈空，结束。</p><p>按照这个思路，我们来编写一下程序吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------- 栈 -------------------</span></span><br><span class="line"><span class="keyword">typedef</span> Node T;   <span class="comment">//这里栈内元素类型定义为上面的Node，也就是二叉树结点指针</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    T element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> * <span class="title">SNode</span>;</span>  <span class="comment">//这里就命名为SNode，不然跟上面冲突了就不好了</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(SNode head)</span>&#123;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(SNode head, T element)</span>&#123;</span><br><span class="line">    SNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> StackNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(SNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T <span class="title function_">popStack</span><span class="params">(SNode head)</span>&#123;</span><br><span class="line">    SNode top = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    T e = top-&gt;element;</span><br><span class="line">    <span class="built_in">free</span>(top);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> <span class="title">stack</span>;</span>  <span class="comment">//栈先搞出来</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (root || !isEmpty(&amp;<span class="built_in">stack</span>))&#123;   <span class="comment">//两个条件，只有当栈空并且节点为NULL时才终止循环</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;    <span class="comment">//按照我们的思路，先不断遍历左子树，直到没有为止</span></span><br><span class="line">            pushStack(&amp;<span class="built_in">stack</span>, root);   <span class="comment">//途中每经过一个结点，就将结点丢进栈中</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//然后打印当前结点元素值</span></span><br><span class="line">            root = root-&gt;left;  <span class="comment">//继续遍历下一个左孩子结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = popStack(&amp;<span class="built_in">stack</span>);  <span class="comment">//经过前面的循环，明确左子树全部走完了，接着就是右子树了</span></span><br><span class="line">        root = root-&gt;right;  <span class="comment">//得到右孩子，如果有右孩子，下一轮会重复上面的步骤；如果没有右孩子那么这里的root就被赋值为NULL了，下一轮开始会直接跳过上面的while，继续出栈下一个结点再找右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就通过非递归的方式实现了前序遍历，可以看到代码是相当复杂的，也不推荐这样编写。</p><p>那么前序遍历我们了解完了，接着就是中序遍历了，中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。</p><p>我们还是以上面的二叉树为例：</p><p><img src="https://s2.loli.net/2022/08/06/W6Yb5M92gQApNJa.png" alt="image-20220806230603967"></p><p>首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。</p><ol><li>中序遍历左子树</li><li>打印结点</li><li>中序遍历右子树</li></ol><p>所以这棵二叉树的中序遍历结果为：DBEACF，我们可以发现一个规律，就是在某个结点的左子树中所有结点，其中序遍历结果也是按照这样的规律排列的，比如A的左子树中所有结点，中序遍历结果中全部都在A的左边，右子树中所有的结点，全部都在A的右边（这个规律很关键，后面在做一些算法题时会用到）</p><p>那么怎么才能将打印调整到左子树全部遍历结束之后呢？其实很简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);  <span class="comment">//先完成全部左子树的遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//等待左子树遍历完成之后再打印</span></span><br><span class="line">    inOrder(root-&gt;right);   <span class="comment">//然后就是对右子树进行遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要将打印放到左子树遍历之后即可，这样打印出来的结果就是中序遍历的结果了：</p><p><img src="https://s2.loli.net/2022/08/06/V2KdMy3T5Beo8vx.png" alt="image-20220806231752418"></p><p>同样的，如果采用的是非递归，那么我也只需要稍微改动一个地方即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (root || !isEmpty(&amp;<span class="built_in">stack</span>))&#123;   <span class="comment">//其他都不变</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            pushStack(&amp;<span class="built_in">stack</span>, root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = popStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//只需要将打印时机延后到左子树遍历完成</span></span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了二叉树的中序遍历，实际上还是很好理解的。</p><p>接着我们来看一下后序遍历，后序遍历继续将打印的时机延后，需要等待左右子树全部遍历完成，才会去进行打印。</p><p><img src="https://s2.loli.net/2022/08/06/YE2rODdqpCInUa9.png" alt="image-20220806233407910"></p><p>首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树，发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>打印结点</li></ol><p>所以最后的遍历顺序为：DEBFCA，不难发现，整棵二叉树（包括子树）根结点一定是在后面的，比如A在所有的结点的后面，B在其子节点D、E的后面，这一点恰恰和前序遍历相反（注意不是得到的结果相反，是规律相反）</p><p>所以，按照这个思路，我们来编写一下后序遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//时机延迟到最后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.loli.net/2022/08/06/6Vx9fmSUcqw51Mp.png" alt="image-20220806234428922"></p><p>不过难点来了，后序遍历使用非递归貌似写不了啊？因为按照我们的之前的思路，最多也就实现中序遍历，我们没办法在一次循环中得知右子树是否完成遍历，难点就在这里。那么我们就要想办法先让右子树完成遍历，由于一个结点需要左子树全部完成+右子树全部完成，而目前只能明确左子树完成了遍历（也就是内层while之后，左子树一定结束了）所以我们可以不急着将结点出栈，而是等待其左右都完事了再出栈，这里我们需要稍微对结点的结构进行修改，添加一个标记变量，来表示已经完成左边还是左右都完成了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> flag;   <span class="comment">//需要经历左右子树都被遍历才行，这里用flag存一下状态，0表示左子树遍历完成，1表示右子树遍历完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">peekStack</span><span class="params">(SNode head)</span>&#123;   <span class="comment">//这里新增一个peek操作，用于获取栈顶元素的值，但是不出栈，仅仅是值获取</span></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (root || !isEmpty(&amp;<span class="built_in">stack</span>))&#123;   <span class="comment">//其他都不变</span></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            pushStack(&amp;<span class="built_in">stack</span>, root);</span><br><span class="line">            root-&gt;flag = <span class="number">0</span>;    <span class="comment">//首次入栈时，只能代表左子树遍历完成，所以flag置0</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = peekStack(&amp;<span class="built_in">stack</span>);   <span class="comment">//注意这里只是获取到结点，并没有进行出栈操作，因为需要等待右子树遍历完才能出栈</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;flag == <span class="number">0</span>) &#123;    <span class="comment">//如果仅仅遍历了左子树，那么flag就等于0</span></span><br><span class="line">            root-&gt;flag = <span class="number">1</span>;   <span class="comment">//此时标记为1表示遍历右子树</span></span><br><span class="line">            root = root-&gt;right;   <span class="comment">//这里跟之前是一样的</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//当flag为1时走这边，此时左右都遍历完成了，这时再打印值出来</span></span><br><span class="line">            popStack(&amp;<span class="built_in">stack</span>);   <span class="comment">//这时再把对应的结点出栈，因为左右都完事了</span></span><br><span class="line">            root = <span class="literal">NULL</span>;   <span class="comment">//置为NULL，下一轮直接跳过while，然后继续取栈中剩余的结点，重复上述操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，后序遍历的非递归写法的最大区别是将结点的出栈时机和打印时机都延后了。</p><p>最后我们来看层序遍历，实际上这种遍历方式是我们人脑最容易理解的，它是按照每一层在进行遍历：</p><p><img src="https://s2.loli.net/2022/08/07/ywF6r9MU1JSPIge.png" alt="image-20220807205135936"></p><p>层序遍历实际上就是按照从上往下每一层，从左到右的顺序打印每个结点，比如上面的这棵二叉树，那么层序遍历的结果就是：ABCDEF，像这样一层一层的挨个输出。</p><p>虽然理解起来比较简单，但是如果让你编程写出来，该咋搞？是不是感觉有点无从下手？</p><p>我们可以利用队列来实现层序遍历，首先将根结点存入队列中，接着循环执行以下步骤：</p><ul><li>进行出队操作，得到一个结点，并打印结点的值。</li><li>将此结点的左右孩子结点依次入队。</li></ul><p>不断重复以上步骤，直到队列为空。</p><p>我们来分析一下，首先肯定一开始A在里面：</p><p><img src="https://s2.loli.net/2022/08/07/ZsNpeVUivEjCymt.png" alt="image-20220807211522409"></p><p>接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/v8yXWNato3sfeUn.png" alt="image-20220807211631110"></p><p>现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/Qkprfi5RhAXP7Cd.png" alt="image-20220807211723776"></p><p>现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队：</p><p><img src="https://s2.loli.net/2022/08/07/MxQTArlWK2gDjqi.png" alt="image-20220807211800852"></p><p>我们发现，这个过程中，打印的顺序正好就是我们层序遍历的顺序，所以说队列还是非常有用的。</p><p>那么现在我们就来上代码吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------- 队列 ----------------</span></span><br><span class="line"><span class="keyword">typedef</span> Node T;   <span class="comment">//还是将Node作为元素</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    T element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> * <span class="title">QNode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    QNode front, rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">LinkedQueue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    QNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, T element)</span>&#123;</span><br><span class="line">    QNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> QueueNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T <span class="title function_">pollQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    T e = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;element;</span><br><span class="line">    QNode node = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front-&gt;next = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;rear == node) <span class="built_in">queue</span>-&gt;rear = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="built_in">free</span>(node);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">levelOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span>   <span class="comment">//先搞一个队列</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, root);  <span class="comment">//先把根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">queue</span>)) &#123;   <span class="comment">//不断重复，直到队列空为止</span></span><br><span class="line">        Node node = pollQueue(&amp;<span class="built_in">queue</span>);   <span class="comment">//出队一个元素，打印值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node-&gt;element);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)    <span class="comment">//如果存在左右孩子的话</span></span><br><span class="line">            offerQueue(&amp;<span class="built_in">queue</span>, node-&gt;left);  <span class="comment">//记得将左右孩子入队，注意顺序，先左后右</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            offerQueue(&amp;<span class="built_in">queue</span>, node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果就是层序遍历的结果：</p><p><img src="https://s2.loli.net/2022/08/07/YlUfDhPoQrg9TkB.png" alt="image-20220807215630429"></p><p>当然，使用递归也可以实现，但是需要单独存放结果然后单独输出，不是很方便，所以说这里就不演示了。</p><p><strong>二叉树练习题：</strong></p><ol><li><p>现在有一棵二叉树前序遍历结果为：ABCDE，中序遍历结果为：BADCE，那么请问该二叉树的后序遍历结果为？</p></li><li><p>对二叉树的结点从1开始连续进行编号，要求每个结点的编号大于其左右孩子的编号，那么请问需要采用哪种遍历方式来实现？</p><p>A. 前序遍历      B. 中序遍历      <strong>C. 后序遍历</strong>     D. 层序遍历</p></li></ol><hr><h2 id="高级树结构"><a href="#高级树结构" class="headerlink" title="高级树结构"></a>高级树结构</h2><p>高级树结构篇是对树结构的延伸扩展，有着特殊的定义和性质，在编写上可能会比较复杂，所以这一部分对于那些太过复杂的结构，就不进行代码编写了，只进行理论讲解。</p><h3 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h3><p>前面我们学习了二叉树，我们知道一棵二叉树实际上可以由多个结点组成，每个结点都有一个左右指针，指向其左右孩子。我们在最后也讲解了二叉树的遍历，包括前序、中序、后序以及层序遍历。只不过在遍历时实在是太麻烦了，我们需要借助栈来帮助我们完成这项遍历操作。</p><p>实际上我们发现，一棵二叉树的某些结点会存在NULL的情况，我们可以利用这些为NULL的指针，将其线索化为某一种顺序遍历的指向下一个按顺序的结点的指针，这样我们在进行遍历的时候，就会很方便了。</p><p>例如，一棵二叉树的前序遍历顺序如下：</p><p><img src="https://s2.loli.net/2022/08/14/ZRjFywa6kWHrbJY.png" alt="image-20220814145531577"></p><p>我们就可以将其进行线索化，首先还是按照前序遍历的顺序依次寻找：</p><p><img src="https://s2.loli.net/2022/08/14/Wu954jeLJhbxXDr.png" alt="image-20220814150731326"></p><p>线索化的规则为：</p><ul><li>结点的左指针，指向其当前遍历顺序的前驱结点。</li><li>结点的右指针，指向其当前遍历顺序的后继结点。</li></ul><p>所以在线索化之后，G的指向情况如下：</p><p><img src="https://s2.loli.net/2022/08/14/ExhJStz4eMoCRF1.png" alt="image-20220814151342130"></p><p>这样，G原本两个为NULL的指针就被我们利用起来了，但是现在有一个问题，我们怎么知道，某个结点的指针到底是指向的其左右孩子，还是说某种遍历顺序下的前驱或是后继结点呢？所以，我们还需要分别为左右添加一个标志位，来表示左右指针到底指向的是孩子还是遍历线索：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> leftTag, rightTag;   <span class="comment">//标志位，如果为1表示这一边指针指向的是线索，不为1就是正常的孩子结点</span></span><br><span class="line">&#125; * Node;</span><br></pre></td></tr></table></figure><p>接着是H结点，同样的，因为H结点的左右指针都是NULL，那么我们也可以将其线索化：</p><p><img src="https://s2.loli.net/2022/08/14/pVo6FHquyBWmS7f.png" alt="image-20220814152008732"></p><p>接着我们来看结点E，这个结点只有一个右孩子，没有左孩子，左孩子指针为NULL，我们也可以将其线索化：</p><p><img src="https://s2.loli.net/2022/08/14/2nUPAuVOvcQKw7L.png" alt="image-20220814152117861"></p><p>最后，整棵二叉树完成线索化之后，除了遍历顺序的最后一个结点没有后续之外，其他为NULL的指针都被利用起来了：</p><p><img src="https://s2.loli.net/2022/08/14/SpWPAbzXRFcOgZJ.png" alt="image-20220814152341658"></p><p>我们可以发现，在利用上那些为NULL的指针之后，当我们再次进行前序遍历时，我们不需要再借助栈了，而是可以一路向前。</p><p>这里我们弄一个简单一点的线索化二叉树，来尝试对其进行遍历：</p><p><img src="https://s2.loli.net/2022/08/14/E1YyemquOdasTRi.png" alt="image-20220814152703468"></p><p>首先我们要对这棵二叉树进行线索化，将其变成一棵线索化二叉树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">createNode</span><span class="params">(E element)</span>&#123;   <span class="comment">//单独写了个函数来创建结点</span></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;rightTag = node-&gt;leftTag = <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node a = createNode(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    Node b = createNode(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    Node c = createNode(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    Node d = createNode(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    Node e = createNode(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    a-&gt;left = b;</span><br><span class="line">    b-&gt;left = d;</span><br><span class="line">    a-&gt;right = c;</span><br><span class="line">    b-&gt;right = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上要将其进行线索化，我们只需要正常按照对应的遍历顺序进行即可，不过在遍历过程中需要留意那些存在空指针的结点，我们需要修改其指针的指向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//别急着写打印</span></span><br><span class="line">    preOrderThreaded(root-&gt;left);</span><br><span class="line">    preOrderThreaded(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先还是老规矩，先把前序遍历写出来，然后我们需要进行判断，如果存在指针指向为NULL，那么就将其线索化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="literal">NULL</span>;  <span class="comment">//这里我们需要一个pre来保存后续结点的指向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;   <span class="comment">//首先判断当前结点左边是否为NULL，如果是，那么指向上一个结点</span></span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        root-&gt;leftTag = <span class="number">1</span>;  <span class="comment">//记得修改标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;  <span class="comment">//然后是判断上一个结点的右边是否为NULL，如果是那么进行线索化，指向当前结点</span></span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;  <span class="comment">//记得修改标记</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pre = root;   <span class="comment">//每遍历完一个，需要更新一下pre，表示上一个遍历的结点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>)   <span class="comment">//注意只有标志位是0才可以继续向下，否则就是线索了</span></span><br><span class="line">    preOrderThreaded(root-&gt;left);</span><br><span class="line">  <span class="keyword">if</span>(root-&gt;rightTag == <span class="number">0</span>)</span><br><span class="line">    preOrderThreaded(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在我们进行二叉树的遍历时，会自动将其线索化，线索化完成之后就是一棵线索化二叉树了。</p><p><img src="https://s2.loli.net/2022/08/14/kxhAsiWCSYMdB7q.png" alt="image-20220814154539765"></p><p>可以看到结点D的左右标记都是1，说明都被线索化了，并且D的左边指向的是其前一个结点B，右边指向的是后一个结点E，这样我们就成功将其线索化了。</p><p>现在我们成功得到了一棵线索化之后的二叉树，那么怎么对其进行遍历呢？我们只需要一个简单的循环就可以了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;  <span class="comment">//前序遍历一棵线索化二叉树非常简单</span></span><br><span class="line">    <span class="keyword">while</span> (root) &#123;   <span class="comment">//到头为止</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//因为是前序遍历，所以直接按顺序打印就行了</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>) </span><br><span class="line">            root = root-&gt;left;   <span class="comment">//如果是左孩子，那么就走左边</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root = root-&gt;right;   <span class="comment">//如果左边指向的不是孩子，而是线索，那么就直接走右边，因为右边无论是线索还是孩子，都要往这边走了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看看中序遍历的线索化二叉树，整个线索化过程我们只需要稍微调整位置就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="literal">NULL</span>;  <span class="comment">//这里我们需要一个pre来保存后续结点的指向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>)</span><br><span class="line">        inOrderThreaded(root-&gt;left);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//------  线索化 -------  现在放到中间去，其他的还是一样的</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        root-&gt;leftTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="comment">//--------------------</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rightTag == <span class="number">0</span>)</span><br><span class="line">        inOrderThreaded(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们线索化完成之后，长这样了：</p><p><img src="https://s2.loli.net/2022/08/14/tsEJLRFCYVaTOP8.png" alt="image-20220814161529021"></p><p>那么像这样的一棵树，我们怎么对其进行遍历呢？中序遍历要稍微麻烦一些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;   <span class="comment">//因为中序遍历需要先完成左边，所以说要先走到最左边才行</span></span><br><span class="line">        <span class="keyword">while</span> (root &amp;&amp; root-&gt;leftTag == <span class="number">0</span>)    <span class="comment">//如果左边一直都不是线索，那么就一直往左找，直到找到一个左边是线索的为止，表示到头了</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//到最左边了再打印，中序开始</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root &amp;&amp; root-&gt;rightTag == <span class="number">1</span>) &#123;   <span class="comment">//打印完就该右边了，右边如果是线索化之后的结果，表示是下一个结点，那么就一路向前，直到不是为止</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, root-&gt;element);   <span class="comment">//注意按着线索往下就是中序的结果，所以说沿途需要打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        root = root-&gt;right;  <span class="comment">//最后继续从右结点开始，重复上述操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来看看后序遍历的线索化，同样的，我们只需要在线索化时修改为后序就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="literal">NULL</span>;  <span class="comment">//这里我们需要一个pre来保存后续结点的指向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>)</span><br><span class="line">        inOrderThreaded(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rightTag == <span class="number">0</span>)</span><br><span class="line">        inOrderThreaded(root-&gt;right);</span><br><span class="line">    <span class="comment">//------  线索化 -------   现在这一坨移到最后，就是后序遍历的线索化了</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        root-&gt;leftTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="comment">//--------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线索化完成之后，变成一棵后续线索化二叉树：</p><p><img src="https://s2.loli.net/2022/08/14/Smqt1UKjeWXFRPu.png" alt="image-20220814162606692"></p><p>后序遍历的结果看起来有点怪怪的，但是这就是后序，那么怎么对这棵线索化二叉树进行后续遍历呢？这就比较复杂了。首先后续遍历需要先完成左右，左边还好说，关键是右边，右边完事之后我们并不一定能找到对应子树的根结点，比如我们按照上面的线索，先从D开始，根据线索找到E，然后继续跟据线索找到B，但是此时B无法找到其兄弟结点C，所以说这样是行不通的，因此要完成后续遍历，我们只能对结点进行改造：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">parent</span>;</span>   <span class="comment">//指向双亲（父）结点</span></span><br><span class="line">    <span class="type">int</span> leftTag, rightTag;</span><br><span class="line">&#125; * Node;</span><br></pre></td></tr></table></figure><p>现在每个结点都保存其父结点，这样就可以顺利地找上去了。现在我们来编写一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Node pre = <span class="literal">NULL</span>;  <span class="comment">//这里我们需要一个pre来保存后续结点的指向</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">postOrderThreaded</span><span class="params">(Node root)</span>&#123;   <span class="comment">//前序遍历线索化函数</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;leftTag == <span class="number">0</span>) &#123;</span><br><span class="line">        postOrderThreaded(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left) root-&gt;left-&gt;parent = root;  <span class="comment">//左边完事之后，如果不为空，那么就设定父子关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;rightTag == <span class="number">0</span>) &#123;</span><br><span class="line">        postOrderThreaded(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right) root-&gt;right-&gt;parent = root;   <span class="comment">//右边完事之后，如果不为空，那么就设定父子关系</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//------  线索化 -------</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        root-&gt;left = pre;</span><br><span class="line">        root-&gt;leftTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre &amp;&amp; pre-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;right = root;</span><br><span class="line">        pre-&gt;rightTag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = root;</span><br><span class="line">    <span class="comment">//--------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    Node last = <span class="literal">NULL</span>, node = root;  <span class="comment">//这里需要两个暂存指针，一个记录上一次遍历的结点，还有一个从root开始</span></span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node-&gt;left != last &amp;&amp; node-&gt;leftTag == <span class="number">0</span>)    <span class="comment">//依然是从整棵树最左边结点开始，和前面一样，只不过这里加入了防无限循环机制，看到下面就知道了</span></span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">while</span> (node &amp;&amp; node-&gt;rightTag == <span class="number">1</span>) &#123;   <span class="comment">//左边完了还有右边，如果右边是线索，那么直接一路向前，也是跟前面一样的</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node-&gt;element);   <span class="comment">//沿途打印</span></span><br><span class="line">            last = node;</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == root &amp;&amp; node-&gt;right == last) &#123;</span><br><span class="line">            <span class="comment">//上面的操作完成之后，那么当前结点左右就结束了，此时就要去寻找其兄弟结点了，我们可以</span></span><br><span class="line">            <span class="comment">//直接通过parent拿到兄弟结点，但是如果当前结点是根结点，需要特殊处理，因为根结点没有父结点了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node-&gt;element);</span><br><span class="line">            <span class="keyword">return</span>;   <span class="comment">//根节点一定是最后一个，所以说直接返回就完事</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (node &amp;&amp; node-&gt;right == last) &#123;    <span class="comment">//如果当前结点的右孩子就是上一个遍历的结点，那么一直向前就行</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, node-&gt;element);   <span class="comment">//直接打印当前结点</span></span><br><span class="line">            last = node;</span><br><span class="line">            node = node-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这里只有一种情况了，是从左子树上来的，那么当前结点的右边要么是线索要么是右子树，所以直接向右就完事</span></span><br><span class="line">        <span class="keyword">if</span>(node &amp;&amp; node-&gt;rightTag == <span class="number">0</span>) &#123;  <span class="comment">//如果不是线索，那就先走右边，如果是，等到下一轮再说</span></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，有关线索化二叉树，我们就讲解到这样。</p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>还记得我们开篇讲到的二分搜索算法吗？通过不断缩小查找范围，最终我们可以以很高的效率找到有序数组中的目标位置。而二叉查找树则利用了类似的思想，我们可以借助其来像二分搜索那样快速查找。</p><p><strong>二叉查找树</strong>也叫二叉搜索树或是二叉排序树，它具有一定的规则：</p><ul><li>左子树中所有结点的值，均小于其根结点的值。</li><li>右子树中所有结点的值，均大于其根结点的值。</li><li>二叉搜索树的子树也是二叉搜索树。</li></ul><p>一棵二叉搜索树长这样：</p><p><img src="https://s2.loli.net/2022/08/14/k9G7Ad2cqezgEtJ.png" alt="image-20220814191444130"></p><p>这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点：</p><ol><li>从根结点18开始，因为15小于18，所以从左边开始找。</li><li>接着来到10，发现10比15小，所以继续往右边走。</li><li>来到15，成功找到。</li></ol><p>实际上，我们在对普通二叉树进行搜索时，可能需要挨个进行查看比较，而有了二叉搜索树，查找效率就大大提升了，它就像我们前面的二分搜索那样。</p><p>因为二叉搜索树要求比较严格，所以我们在插入结点时需要遵循一些规律，这里我们来尝试编写一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">createNode</span><span class="params">(E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就以上面这颗二叉查找树为例，现在我们想要依次插入这些结点，我们需要编写一个特殊的插入操作，这里需要注意一下，二叉查找树不能插入重复元素，如果出现重复直接忽略：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">insert</span><span class="params">(Node root, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;element &gt; element)    <span class="comment">//如果插入结点值小于当前结点，那么说明应该放到左边去</span></span><br><span class="line">            root-&gt;left = insert(root-&gt;left, element);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &lt; element)    <span class="comment">//如果插入结点值大于当前结点，那么说明应该放到右边去</span></span><br><span class="line">            root-&gt;right = insert(root-&gt;right, element);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">//当结点为空时，说明已经找到插入的位置了，创建对应结点</span></span><br><span class="line">        root = createNode(element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;   <span class="comment">//返回当前结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以通过不断插入创建一棵二叉查找树了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;element);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node root = insert(<span class="literal">NULL</span>, <span class="number">18</span>);   <span class="comment">//插入后，得到根结点</span></span><br><span class="line">    inOrder(root);   <span class="comment">//用中序遍历查看一下结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照顺序来，首先是根结点的左右孩子，分别是10和20，那么这里我们就依次插入一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node root = insert(<span class="literal">NULL</span>, <span class="number">18</span>);   <span class="comment">//插入后，得到根结点</span></span><br><span class="line">    insert(root, <span class="number">10</span>);</span><br><span class="line">    insert(root, <span class="number">20</span>);</span><br><span class="line">    inOrder(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到中序结果为：</p><p><img src="https://s2.loli.net/2022/08/15/FlLRBprEezot5Z8.png" alt="image-20220815094708456"></p><p>比18小的结点在左边，大的在右边，满足二叉查找树的性质。接着是7、15、22：</p><p><img src="https://s2.loli.net/2022/08/15/chEUaOBzCTl4N8G.png" alt="image-20220815094823646"></p><p>最后再插入9就是我们上面的这棵二叉查找树了。当然我们直接写成控制台扫描的形式，就更方便了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        E element;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;element);</span><br><span class="line">        root = insert(root, element);</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么插入写好之后，我们怎么找到对应的结点呢？实际上也是按照规律来就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">find</span><span class="params">(Node root, E target)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;element &gt; target)    <span class="comment">//如果要找的值比当前结点小，说明肯定在左边</span></span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &lt; target)   <span class="comment">//如果要找的值比当前结点大，说明肯定在右边</span></span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> root;   <span class="comment">//等于的话，说明找到了，就直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//都找到底了还没有，那就是真没有了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">findMax</span><span class="params">(Node root)</span>&#123;   <span class="comment">//查找最大值就更简单了，最右边的一定是最大的</span></span><br><span class="line">    <span class="keyword">while</span> (root &amp;&amp; root-&gt;right) </span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试查找一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Node root = insert(<span class="literal">NULL</span>, <span class="number">18</span>);   <span class="comment">//插入后，得到根结点</span></span><br><span class="line">    insert(root, <span class="number">10</span>);</span><br><span class="line">    insert(root, <span class="number">20</span>);</span><br><span class="line">    insert(root, <span class="number">7</span>);</span><br><span class="line">    insert(root, <span class="number">15</span>);</span><br><span class="line">    insert(root, <span class="number">22</span>);</span><br><span class="line">    insert(root, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, find(root, <span class="number">17</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, find(root, <span class="number">9</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/15/lFOaUphkbB3wxIC.png" alt="image-20220815095915453"></p><p>搜索17的结果为NULL，说明没有这个结点，而9则成功找到了。</p><p>最后我们来看看二叉查找树的删除操作，这个操作就比较麻烦了，因为可能会出现下面的几种情况：</p><ol><li>要删除的结点是叶子结点。</li><li>要删除的结点是只有一个孩子结点。</li><li>要删除的结点有两个孩子结点。</li></ol><p>首先我们来看第一种情况，这种情况实际上最好办，直接删除就完事了：</p><p><img src="https://s2.loli.net/2022/08/15/7RWkPXh6po2HjNz.png" alt="image-20220815104036598"></p><p>而第二种情况，就有点麻烦了，因为有一个孩子，就像一个拖油瓶一样，你离开了还不行，你还得对他负责才可以。当移除后，需要将孩子结点连接上去：</p><p><img src="https://s2.loli.net/2022/08/15/4IZVf3SaCugD8Qc.png" alt="image-20220815104553978"></p><p>可以看到在调整后，依然满足二叉查找树的性质。最后是最麻烦的有两个孩子的情况，这种该怎么办呢？前面只有一个孩子直接上位就完事，但是现在两个孩子，到底谁上位呢？这就不好办了，为了保持二叉查找树的性质，现在有两种选择：</p><ol><li>选取其左子树中最大结点上位</li><li>选择其右子树中最小结点上位</li></ol><p>这里我们以第一种方式为例：</p><p><img src="https://s2.loli.net/2022/08/15/jPRG68tru4bvIFa.png" alt="image-20220815110311555"></p><p>现在我们已经分析完三种情况了，那么我们就来编写一下代码吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">delete</span><span class="params">(Node root, E target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//都走到底了还是没有找到要删除的结点，说明没有，直接返回空</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;element &gt; target)   <span class="comment">//这里的判断跟之前插入是一样的，继续往后找就完事，直到找到为止</span></span><br><span class="line">        root-&gt;left = delete(root-&gt;left, target);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &lt; target)</span><br><span class="line">        root-&gt;right = delete(root-&gt;right, target);</span><br><span class="line">    <span class="keyword">else</span> &#123;   <span class="comment">//这种情况就是找到了</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;right) &#123;   <span class="comment">//先处理最麻烦的左右孩子都有的情况</span></span><br><span class="line">            Node max = findMax(root-&gt;left);  <span class="comment">//寻找左子树中最大的元素</span></span><br><span class="line">            root-&gt;element = max-&gt;element;  <span class="comment">//找到后将值替换</span></span><br><span class="line">            root-&gt;left = delete(root-&gt;left, root-&gt;element);  <span class="comment">//替换好后，以同样的方式去删除那个替换上来的结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">//其他两种情况可以一起处理，只需要删除这个结点就行，然后将root指定为其中一个孩子，最后返回就完事</span></span><br><span class="line">            Node tmp = root;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;   <span class="comment">//不是左边就是右边</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(tmp);   <span class="comment">//开删</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;   <span class="comment">//返回最终的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了二叉查找树的各种操作，当然目前为止我们了解的二叉树高级结构还比较简单，后面就开始慢慢复杂起来了。</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>前面我们介绍了二叉查找树，利用二叉查找树，我们在搜索某个值的时候，效率会得到巨大提升。但是虽然看起来比较完美，也是存在缺陷的，比如现在我们依次将下面的值插入到这棵二叉树中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 15 13 8 6 3</span><br></pre></td></tr></table></figure><p>在插入完成后，我们会发现这棵二叉树竟然长这样：</p><p><img src="https://s2.loli.net/2022/08/15/E1Pf2pGv4b9Lj7t.png" alt="image-20220815113242191"></p><p>因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。</p><p>所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的：</p><p><img src="https://s2.loli.net/2022/08/15/k1jzXPoOMp9caHy.png" alt="image-20220815113705827"></p><p>所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入<strong>平衡二叉树</strong>的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，<strong>平衡二叉树</strong>（AVL树）就是为了解决这样的问题而生的。</p><p>它的性质如下：</p><ul><li>平衡二叉树一定是一棵二叉查找树。</li><li>任意结点的左右子树也是一棵平衡二叉树。</li><li>从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。</li></ul><p>可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度 减去 右子树高度， 得到的结果称为该节点的<strong>平衡因子</strong>（Balance Factor），比如：</p><p><img src="https://s2.loli.net/2022/08/15/vaI9qji1KYOP8kt.png" alt="image-20220815210652973"></p><p>通过计算平衡因子，我们就可以快速得到是否出现失衡的情况。比如下面的这棵二叉树，正在执行插入操作：</p><p><img src="https://s2.loli.net/2022/08/15/DMnPqGhawy5Z92V.png" alt="image-20220815115219250"></p><p>可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡：</p><p><img src="https://s2.loli.net/2022/08/15/KcOQVhlFxzwsIb9.png" alt="image-20220815115836604"></p><p>根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡：</p><p>动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html%EF%BC%88%E5%AE%9E%E5%9C%A8%E4%B8%8D%E7%90%86%E8%A7%A3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E5%8A%A8%E7%94%BB%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E7%9A%84%EF%BC%89">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html（实在不理解可以看看动画是怎么走的）</a></p><ol><li><p><strong>LL型调整</strong>（右旋）</p><p><img src="https://s2.loli.net/2022/08/15/KqBaWLJwOj34Ec8.png" alt="image-20220815211641144"></p><p>首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行<strong>旋转</strong>来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢？对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个：</p><p><img src="https://s2.loli.net/2022/08/15/q4aYvzrnjdTgAtK.png" alt="image-20220815212552176"></p><p>可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树：</p><p><img src="https://s2.loli.net/2022/08/15/fJKz3FWclm9orVT.png" alt="image-20220815213222964"></p><p>这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。</p></li><li><p><strong>RR型调整</strong>（左旋）</p><p>前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可：</p><p><img src="https://s2.loli.net/2022/08/15/kIl8ZT6Psr7mNSg.png" alt="image-20220815214026710"></p><p>操作和上面是一样的，只不过现在反过来了而已：</p><p><img src="https://s2.loli.net/2022/08/15/LB9DOJpyIlxQWTm.png" alt="image-20220815214408651"></p><p>这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。</p></li><li><p><strong>RL型调整</strong>（先右旋，再左旋）</p><p>剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样：</p><p><img src="https://s2.loli.net/2022/08/15/fwcrEIgBxWLVGXs.png" alt="image-20220815214859501"></p><p>可以看到现在的形状是一个回旋镖形状的，先右后左的一个状态，也就是RL型，针对于这种情况，我们需要先进行右旋操作，注意这里的右旋操作针对的是后两个结点：</p><p><img src="https://s2.loli.net/2022/08/15/ukK6C4PNBwoaJbc.png" alt="image-20220815215929303"></p><p>其中右旋和左旋的操作，与之前一样，该怎么分配左右子树就怎么分配，完成两次旋转后，可以看到二叉树重新变回了平衡状态。</p></li><li><p><strong>LR型调整</strong>（先左旋，再右旋）</p><p>和上面一样，我们来看看LR型长啥样，其实就是反着的：</p><p><img src="https://s2.loli.net/2022/08/15/6Cj8VlgGekULXvP.png" alt="image-20220815220609357"></p><p>形状是先向左再向右，这就是典型的LR型了，我们同样需要对其进行两次旋转：</p><p><img src="https://s2.loli.net/2022/08/15/y6WscFPxHuzTiaI.png" alt="image-20220815221349044"></p><p>这里我们先进行的是左旋，然后再进行的右旋，这样二叉树就能继续保持平衡了。</p></li></ol><p>这样，我们只需要在插入结点时注意维护整棵树的平衡因子，保证其处于稳定状态，这样就可以让这棵树一直处于高度平衡的状态，不会再退化了。这里我们就编写一个插入结点代码来实现一下吧，首先还是结点定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> height;   <span class="comment">//每个结点需要记录当前子树的高度，便于计算平衡因子</span></span><br><span class="line">&#125; * Node;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">createNode</span><span class="params">(E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    node-&gt;height = <span class="number">1</span>;   <span class="comment">//初始化时，高度写为1就可以了</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们需要先将左旋、右旋等操作编写出来，因为一会插入时可能需要用到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">leftRotation</span><span class="params">(Node root)</span>&#123;  <span class="comment">//左旋操作，实际上就是把左边结点拿上来</span></span><br><span class="line">    Node newRoot = root-&gt;right;   <span class="comment">//先得到左边结点</span></span><br><span class="line">    root-&gt;right = newRoot-&gt;left;   <span class="comment">//将左边结点的左子树丢到原本根结点的右边去</span></span><br><span class="line">    newRoot-&gt;left = root;   <span class="comment">//现在新的根结点左边就是原本的跟结点了</span></span><br><span class="line"></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;right), getHeight(root-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">    newRoot-&gt;height = max(getHeight(newRoot-&gt;right), getHeight(newRoot-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">rightRotation</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    Node newRoot = root-&gt;left;</span><br><span class="line">    root-&gt;left = newRoot-&gt;right;</span><br><span class="line">    newRoot-&gt;right = root;</span><br><span class="line"></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;right), getHeight(root-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">    newRoot-&gt;height = max(getHeight(newRoot-&gt;right), getHeight(newRoot-&gt;left)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> newRoot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">leftRightRotation</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    root-&gt;left = leftRotation(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> rightRotation(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node <span class="title function_">rightLeftRightRotation</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">    root-&gt;right = rightRotation(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> leftRotation(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是我们的插入操作了，注意在插入时动态计算树的高度，一旦发现不平衡，那么就立即采取对应措施：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">insert</span><span class="params">(Node root, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;    <span class="comment">//如果结点为NULL，说明找到了插入位置，直接创建新的就完事</span></span><br><span class="line">        root = createNode(element);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &gt; element) &#123;   <span class="comment">//和二叉搜索树一样，判断大小，该走哪边走哪边，直到找到对应插入位置</span></span><br><span class="line">        root-&gt;left = insert(root-&gt;left, element);</span><br><span class="line">        <span class="keyword">if</span>(getHeight(root-&gt;left) - getHeight(root-&gt;right) &gt; <span class="number">1</span>) &#123;   <span class="comment">//插入完成之后，需要计算平衡因子，看看是否失衡</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left-&gt;element &gt; element) <span class="comment">//接着需要判断一下是插入了左子树的左边还是右边，如果是左边那边说明是LL，如果是右边那说明是LR</span></span><br><span class="line">                root = rightRotation(root);   <span class="comment">//LL型得到左旋之后的结果，得到新的根结点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = leftRightRotation(root);    <span class="comment">//LR型得到先左旋再右旋之后的结果，得到新的根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;element &lt; element)&#123;</span><br><span class="line">        root-&gt;right = insert(root-&gt;right, element);</span><br><span class="line">        <span class="keyword">if</span>(getHeight(root-&gt;left) - getHeight(root-&gt;right) &lt; <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right-&gt;element &lt; element)</span><br><span class="line">                root = leftRotation(root);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root = rightLeftRightRotation(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前面的操作完成之后记得更新一下树高度</span></span><br><span class="line">    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> root;  <span class="comment">//最后返回root到上一级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就完成了平衡二叉树的插入操作，当然删除操作比较类似，也是需要在删除之后判断是否平衡，如果不平衡同样需要进行旋转操作，这里就不做演示了。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><strong>注意：</strong>本小节内容作为选学内容，不强制要求掌握。很多人都说红黑树难，其实就那几条规则，跟着我推一遍其实还是很简单的，当然前提是一定要把前面的平衡二叉树搞明白。</p><p>前面我们讲解了二叉平衡树，通过在插入结点时维护树的平衡，这样就不会出现极端情况使得整棵树的查找效率急剧降低了。但是这样是否开销太大了一点，因为一旦平衡因子的绝对值超过1那么就失衡，这样每插入一个结点，就有很大的概率会导致失衡，我们能否不这么严格，但同时也要在一定程度上保证平衡呢？这就要提到红黑树了。</p><p>在线动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p><p>红黑树也是二叉查找树的一种，它大概长这样，可以看到结点有红有黑：</p><p><img src="https://s2.loli.net/2022/08/15/t86B7sxvYeP9TiR.png" alt="image-20220815222810537"></p><p>它并不像平衡二叉树那样严格要求高度差不能超过1，而是只需要满足五个规则即可，它的规则如下：</p><ul><li>规则1：每个结点可以是黑色或是红色。</li><li>规则2：根结点一定是黑色。</li><li>规则3：红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色。</li><li>规则4：所有的空结点都是黑色（空结点视为NIL，红黑树中是将空节点视为叶子结点）</li><li>规则5：每个结点到空节点（NIL）路径上出现的黑色结点的个数都相等。</li></ul><p>它相比平衡二叉树，通过不严格平衡和改变颜色，就能在一定程度上减少旋转次数，这样的话对于整体性能是有一定提升的，只不过我们在插入结点时，就有点麻烦了，我们需要同时考虑变色和旋转这两个操作了，但是会比平衡二叉树更简单。</p><p>那么什么时候需要变色，什么时候需要旋转呢？我们通过一个简单例子来看看：</p><p><img src="https://s2.loli.net/2022/08/16/wIj5qnhxFAHcyG7.png" alt="image-20220816104917851"></p><p>首先这棵红黑树只有一个根结点，因为根结点必须是黑色，所以说直接变成黑色。现在我们要插入一个新的结点了，所有新插入的结点，默认情况下都是红色：</p><p><img src="https://s2.loli.net/2022/08/16/yHRXgbsvOM27xLr.png" alt="image-20220816105119178"></p><p>所以新来的结点7根据规则就直接放到11的左边就行了，然后注意7的左右两边都是NULL，那么默认都是黑色，这里就不画出来了。同样的，我们往右边也来一个：</p><p><img src="https://s2.loli.net/2022/08/16/kJiA71fQuKHnIdb.png" alt="image-20220816105553070"></p><p>现在我们继续插入一个结点：</p><p><img src="https://s2.loli.net/2022/08/16/VEQLu5mb1tcTyzd.png" alt="image-20220816105656320"></p><p>插入结点4之后，此时违反了红黑树的规则3，因为红色结点的父结点和子结点不能为红色，此时为了保持以红黑树的性质，我们就需要进行<strong>颜色变换</strong>才可以，那么怎么进行颜色变换呢？我们只需要直接将父结点和其兄弟结点同时修改为黑色（为啥兄弟结点也需要变成黑色？因为要满足性质5）然后将爷爷结点改成红色即可：</p><p><img src="https://s2.loli.net/2022/08/16/kuc1B3lqhNUwaSM.png" alt="image-20220816113259643"></p><p>当然这里还需注意一下，因为爷爷结点正常情况会变成红色，相当于新来了个红色的，这时还得继续往上看有没有破坏红黑树的规则才可以，直到没有为止，比如这里就破坏了性质一，爷爷结点现在是根结点（不是根结点就不需要管了），必须是黑色，所以说还要给它改成黑色才算结束：</p><p><img src="https://s2.loli.net/2022/08/16/dpRX5DGsfWVwnQi.png" alt="image-20220816113339344"></p><p>接着我们继续插入结点：</p><p><img src="https://s2.loli.net/2022/08/16/4ZAhv7R9YusI8q6.png" alt="image-20220816113939172"></p><p>此时又来了一个插在4左边的结点，同样是连续红色，我们需要进行变色才可以讲解问题，但是我们发现，如果变色的话，那么从11开始到所有NIL结点经历的黑色结点数量就不对了：</p><p><img src="https://s2.loli.net/2022/08/16/n3M6Kfsb4jHtIci.png" alt="image-20220816114245996"></p><p>所以说对于这种<strong>父结点为红色，父结点的兄弟结点为黑色</strong>（NIL视为黑色）的情况，变色无法解决问题了，那么我们只能考虑旋转了，旋转规则和我们之前讲解的平衡二叉树是一样的，这实际上是一种LL型失衡：</p><p><img src="https://s2.loli.net/2022/08/16/POTaBfosmQiceWk.png" alt="image-20220816115015892"></p><p>同样的，如果遇到了LR型失衡，跟前面一样，先左旋在右旋，然后进行变色即可：</p><p><img src="https://s2.loli.net/2022/08/16/XqFr7hJwe38AakK.png" alt="image-20220816115924938"></p><p>而RR型和RL型同理，这里就不进行演示了，可以看到，红黑树实际上也是通过颜色规则在进行旋转调整的，当然旋转和变色的操作顺序可以交换。所以，在插入时比较关键的判断点如下：</p><ul><li>如果整棵树为NULL，直接作为根结点，变成黑色。</li><li>如果父结点是黑色，直接插入就完事。</li><li>如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构）</li><li>如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。</li></ul><p>在了解这些步骤之后，我们其实已经可以尝试去编写一棵红黑树出来了，当然代码太过复杂，这里就不演示了。其实红黑树难点并不在于如何构建和使用，而是在于，到底是怎么设计出来的，究竟要多么丰富的知识储备才能想到如此精妙的规则。</p><p>红黑树的发明者：</p><blockquote><p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>科学中用到的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>，典型的用途是实现<a href="https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/3317025">关联数组</a>。 </p><p>红黑树是在1972年由[Rudolf Bayer](<a href="https://baike.baidu.com/item/Rudolf">https://baike.baidu.com/item/Rudolf</a> Bayer&#x2F;3014716)发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。</p></blockquote><p>在了解了后面的B树之后，相信我们就能揭开这层神秘面纱了。</p><hr><h2 id="其他树结构"><a href="#其他树结构" class="headerlink" title="其他树结构"></a>其他树结构</h2><p>前面我们介绍了各种各样的二叉树，其实还是比较简单的。我们接着来看一下其他的一些树结构，这一部分我们只做了解即可。</p><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><p>前面我们介绍了多种多样的二叉树，有线索化二叉树，平衡二叉树等等，这些改造版二叉树无疑都是为了提高我们的程序运行效率而生的，我们接着来看一种同样为了提升效率的树结构。</p><p>这里首先介绍一下B树（Balance Tree），它是专门为磁盘数据读取设计的一种度为 m 的查找树（多用于数据库）它同样是一棵平衡树，但是不仅限于二叉了，之前我们介绍的这些的二叉树都是基于内存读取的优化，磁盘读取速度更慢，它同样需要优化，一棵度为4的（4阶）B树大概长这样：</p><p><img src="https://s2.loli.net/2022/08/17/lH9YBVIASQJe26d.png" alt="image-20220817102503116"></p><p>第一眼看上去，感觉好像没啥头绪，不能发现啥规律，但是只要你仔细观察，你会发现，它和二叉查找树很相似，左边的一定比根节点小，右边的一定比根节点大，并且我们发现，每个结点现在可以保存多个值，每个结点可以连接多个子树，这些值两两组合划分了一些区间，比如60左边，一定是比60小的，60和80之间那么就是大于60小于80的值，以此类推，所以值有N个，就可以划分出N+1个区间，那么子树最多就可以有N+1个。它的详细规则如下：</p><ol><li>树中每个结点最多含有m个孩子（m &gt;&#x3D; 2）比如上面就是m为4的4阶B树，最多有4个孩子。</li><li>除根结点和叶子结点外，其它每个结点至少有⌈m&#x2F;2⌉个孩子，同理键值数量至少有⌈m&#x2F;2⌉-1个。</li><li>若根结点不是叶子结点，则至少有2个孩子。</li><li>所有叶子结点都出现在同一层。</li><li>一个结点的包含多种信息（P0，K1，P1，K2，…，Kn，Pn），其中P为指向子树的指针，K为键值（关键字）<ol><li>Ki (i&#x3D;1…n)为键值，也就是每个结点保存的值，且键值按顺序升序排序K(i-1)&lt; Ki  </li><li>Pi为指向子树的指针，且指针Pi指向的子树中所有结点的键值均小于Ki，但都大于K(i-1)  </li><li>键值的个数n必须满足： ⌈m&#x2F;2⌉-1 &lt;&#x3D; n &lt;&#x3D; m-1</li></ol></li></ol><p>在线动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p><p>是不是感觉怎么要求这么多呢？我们通过感受一下B树的插入和删除就知道了，首先是B树的插入操作，这里我们以度为3的B树为例：</p><p><img src="https://s2.loli.net/2022/08/17/CqwaR1s2OyeIVLc.png" alt="image-20220817105907362"></p><p>插入1之后，只有一个结点，我们接着插入一个2，插入元素满足以下规则：</p><ul><li>如果该节点上的元素数未满，则将新元素插入到该节点，并保持节点中元素的顺序。</li></ul><p>所以，直接放进去就行，注意顺序：</p><p><img src="https://s2.loli.net/2022/08/17/HoamJkqwvP2ZlBb.png" alt="image-20220817110243376"></p><p>接着我们再插入一个3进去，但是此时因为度为3，那么键值最多只能有两个，肯定是装不下了：</p><ul><li>如果该节点上的元素已满，则需要将该节点平均地分裂成两个节点：<ol><li>首先从该节点中的所有元素和新元素中先出一个中位数作为<strong>分割值</strong>。</li><li>小于中位数的元素作为左子树划分出去，大于中位数的元素作为右子树划分。</li><li>分割值此时上升到父结点中，如果没有父结点，那么就创建一个新的（这里的上升不太好理解，一会我们推过去就明白了）</li></ol></li></ul><p>所以，当3来了之后，直接进行分裂操作：</p><p><img src="https://s2.loli.net/2022/08/17/aEJxSUlY1t6nVWM.png" alt="image-20220817110803123"></p><p>就像爱情一样，两个人的世界容不下第三者，如果来了第三者，那么最后的结果大概率就是各自分道扬镳。接着我们继续插入4、5看看会发生什么，注意插入还是按照小的走左边，大的走右边的原则，跟我们之前的二叉查找树是一样的：</p><p><img src="https://s2.loli.net/2022/08/17/Az8pmnsXvZaNl6q.png" alt="image-20220817111405624"></p><p>此时4、5来到了右边，现在右边这个结点又被撑爆了，所以说需要按照上面的规则，继续进行分割：</p><p><img src="https://s2.loli.net/2022/08/17/odNZMzeUGWQObtA.png" alt="image-20220817111556446"></p><p>可能各位看着有点奇怪，为啥变成这样了，首先3、4、5三个都分开了，然后4作为分割值，3、5变成两个独立的树，此时4需要上升到父结点，所以直接跑到上面去了，然后3和5出现在4的左右两边。注意这里不是向下划分，反而有点向上划分的意思。为什么不向下划分呢？因为要满足B树第四条规则：所有叶子结点都出现在同一层。</p><p>此时我们继续插入6、7，看看会发生什么情况：</p><p><img src="https://s2.loli.net/2022/08/17/U3ExLbOdD9tpAGW.png" alt="image-20220817111943543"></p><p>此时右下角结点又被挤爆了，右下角真是多灾多难啊，那么依然按照我们之前的操作进行分裂：</p><p><img src="https://s2.loli.net/2022/08/17/nVFhBQoy7w195Sz.png" alt="image-20220817112213868"></p><p>我们发现当新的分割值上升之后最上面的结点又被挤爆了，此时我们需要继续分裂：</p><p><img src="https://s2.loli.net/2022/08/17/kQJZDBbrgyHnac1.png" alt="image-20220817112401155"></p><p>在2、4、6中寻找一个新的分割值，分裂后将其上升到新的父结点中，就像上图那样了。在了解了B树的插入操作之后，是不是有一点感受到这种结构带来的便捷了？</p><p>我们再来看看B树的删除操作，这个要稍微麻烦一些，这里我们以一颗5阶B树为例，现在我们想删除16结点：</p><p><img src="https://s2.loli.net/2022/08/17/VsiQvCfEJ92oLch.png" alt="image-20220817114440027"></p><p>删除后，依然满足B树的性质，所以说什么都不管用：</p><p><img src="https://s2.loli.net/2022/08/17/CzTIN2GeREP7lVU.png" alt="image-20220817114541675"></p><p>此时我们接着去删除15结点：</p><p><img src="https://s2.loli.net/2022/08/17/ypYEDR7gIL4fZ8X.png" alt="image-20220817114722079"></p><p>删除后，现在结点中只有14了，不满足B树的性质：除根结点和叶子结点外，其它每个结点至少有⌈m&#x2F;2⌉个孩子，同理键值数量至少有⌈m&#x2F;2⌉-1个，现在只有一个肯定是不行的。此时我们需向兄弟（注意只能找左右两边的兄弟）借一个过来：</p><p><img src="https://s2.loli.net/2022/08/17/dZVwpNlRzKxHerA.png" alt="image-20220817114956686"></p><p>此时我们继续删掉17，但是兄弟已经没办法再借给我们一个元素了，此时只能采取方案二，合并兄弟节点与分割键。这里我们就合并左边的这个兄弟吧：</p><p><img src="https://s2.loli.net/2022/08/17/wxhF2bJUHlEMGXW.png" alt="image-20220817120014656"></p><p><img src="https://s2.loli.net/2022/08/17/Xp3l8AiDU6Bebwo.png" alt="image-20220817120058865"></p><p>现在他们三个又合并回去了，这下总满足了吧？但是我们发现，父结点此时只有一个元素了，又出问题了。同样的，还是先去找兄弟结点借一个，但是兄弟结点也借不了了，此时继续采取我们的方案二，合并：</p><p><img src="https://s2.loli.net/2022/08/17/E2RzTW5XOJjHdQm.png" alt="image-20220817120402123"></p><p>OK，这样才算是满足了B树的性质，现在我们继续删除4结点：</p><p><img src="https://s2.loli.net/2022/08/17/TBrynM7Ge2lfz31.png" alt="image-20220817120835776"></p><p>这种情况会导致失去分割值，那么我们得找一个新的分割值才行，这里取左边最大的：</p><p><img src="https://s2.loli.net/2022/08/17/pLZJNEyzHAVjfU4.png" alt="image-20220817121020793"></p><p>不过此时虽然解决了分割值的问题，但是新的问题来了，左边结点不满足性质了，元素数量低于限制，于是需要找兄弟结点借，但是没得借了，兄弟也没有多的可以借了所以被迫合并了：</p><p><img src="https://s2.loli.net/2022/08/17/jhT5SNFXwq9niYk.png" alt="image-20220817121250186"></p><p>可以看到整个变换过程中，这颗B树所有子树的高度是一直维持在一个稳定状态的，查找效率能够持续保持。</p><p>删除操作可以总结为两大类：</p><ul><li>若删除的是叶子结点的中元素：<ul><li>正常情况下直接删除。</li><li>如果删除后，键值数小于最小值，那么需要找兄弟借一个。</li><li>要是没得借了，直接跟兄弟结点、对应的分割值合并。</li></ul></li><li>若删除的是某个根结点中的元素：<ul><li>一般情况会删掉一个分割值，删掉后需要重新从左右子树中找一个新分割值的拿上来。</li><li>要是拿上来之后左右子树中出现键值数小于最小值的情况，那么就只能合并了。</li></ul></li><li>上述两个操作执行完后，还要继续往上看上面的结点是否依然满足性质，否则继续处理，直到稳定。</li></ul><p>在了解了B树的相关操作之后，是不是感觉还是挺简单的，依然是动态维护树的平衡。正是得益于B树这种结点少，高度平衡且有序的性质，而硬盘IO速冻远低于内存，我们希望能够花费尽可能少的时间找到我们想要的数据，减少IO次数，B树就非常适合在硬盘上的保存数据，它的查找效率是非常高的。</p><p><strong>注意：以下内容为选学部分：</strong></p><blockquote><p>此时此刻，我们回想一下之前提到的红黑树，我们来看看它和B树有什么渊源，这是一棵很普通的红黑树：</p><p><img src="https://s2.loli.net/2022/08/17/XorTHWdJEt24Zci.png" alt="image-20220817123042186"></p><p>此时我们将所有红色节点上移到与父结点同一高度，</p><p><img src="https://s2.loli.net/2022/08/17/VkJmwZI8XFz9Yl2.png" alt="image-20220817123537220"></p><p>还是没看出来？没关系，我们来挨个画个框：</p><p><img src="https://s2.loli.net/2022/08/17/2TgcNMdztpOEXk6.png" alt="image-20220817123455865"></p><p>woc，这不就是B树吗？没错，<strong>红黑树</strong> 和 <strong>4阶B树</strong>（2-3-4树）具有等价性，其中黑色结点就是中间的（黑色结点一定是父结点)，红色结点分别位于两边，通过将黑色结点与它的红色子节点融合在一起，形成1个B树节点，最后就像这样：</p><p><img src="https://s2.loli.net/2022/08/17/MJiErSB4p856mjd.png" alt="image-20220817153152790"></p><p>你会发现，红黑树的黑色节点个数总是与4阶B树的节点数相等。我们可以对比一下之前的红黑树插入和4阶B树的插入，比如现在我们想要插入一个新的14结点进来：</p><p><img src="https://s2.loli.net/2022/08/17/mNS8zRofZCM6quE.png" alt="image-20220817153955759"></p><p>经过变色，最后得到如下的红黑树，此时又出现两个红色结点连续，因为父结点的兄弟结点依然是红色，继续变色：</p><p><img src="https://s2.loli.net/2022/08/17/DE5UTIkbdBvAoL9.png" alt="image-20220817154655210"></p><p>最后因为根结点必须是黑色，所以说将60变为黑色，这样就插入成功了：</p><p><img src="https://s2.loli.net/2022/08/17/4nqCNJeFxQbmRGy.png" alt="image-20220817154751660"></p><p>我们再来看看与其等价的B树插入14后会怎么样：</p><p><img src="https://s2.loli.net/2022/08/17/ltno5TuiHAb3QNj.png" alt="image-20220817154838567"></p><p>由于B树的左边被挤爆了，所以说需要分裂，因为是偶数个，需要选择中间偏右的那个数作为分割值，也就是25：</p><p><img src="https://s2.loli.net/2022/08/17/jZ4EvWynm5aQelq.png" alt="image-20220817160036666"></p><p>分裂后，分割值上升，又把父结点给挤爆了，所以说需要继续分裂：</p><p><img src="https://s2.loli.net/2022/08/17/7SRHOMucikbnml3.png" alt="image-20220817160244020"></p><p>现在就变成了这样，我们来对比一下红黑树：</p><p><img src="https://s2.loli.net/2022/08/17/arxhpI1ytvq7wO9.png" alt="image-20220817160427011"></p><p>不能说很像，只能说是一模一样啊。为什么呢？明明这两种树是不同的规则啊，为什么会出现等价的情况呢？</p><ul><li>B树叶节点等深实际上体现在红黑树中为任一叶节点到达根节点的路径中，黑色路径所占的长度是相等的，因为黑色结点就是B树的结点分割值。</li><li>B树节点的键值数量不能超过N实际上体现在红黑树约定相邻红色结点接最多2条，也就是说不可能出现B树中元素超过3的情况，因为是4阶B树。</li></ul><p>所以说红黑树跟4阶B树是有一定渊源的，甚至可以说它就是4阶B树的变体。</p></blockquote><p>前面我们介绍了B树，现在我们就可以利用B树来高效存储数据了，当然我们还可以让它的查找效率更高。这里我们就要提到B+树了，B+树是B树的一种变体，有着比B树更高的查询性能。</p><ol><li>有k个子树的中间结点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据（卫星数据，就是具体需要保存的内容）都保存在叶子结点。</li><li>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点按照从小到大的顺序连接。</li><li>所有的根结点元素都同时存在于子结点中，在子节点元素中是最大（或最小）元素。</li></ol><p>我们来看看一棵B+树长啥样：</p><p><img src="https://s2.loli.net/2022/08/17/C4utSmNvKPAaZ35.png" alt="image-20220817163343975"></p><p>其中最后一层形成了一个有序链表，在我们需要顺序查找时，提供了极大的帮助。可以看到现在除了最后一层之外，其他结点中存放的值仅仅充当了一个指路人的角色，来告诉你你需要的数据在哪一边，比如根节点有10和18，因为这里是取得最大值，那么整棵树最大的元素就是18了，我们现在需要寻找一个小于18大于10的数，就可以走右边去查找。而具体的数据会放到最下面的叶子结点中，比如数据库就是具体的某一行数据（卫星数据）存放在最下面：</p><p><img src="https://s2.loli.net/2022/08/17/pW5SiDqmNY2PXfZ.png" alt="image-20220817163816562"></p><p>当然，目前可能你还没有接触过数据库，在以后的学习中，你一定会接触到它的，到时你就会发现新世界。</p><p>它不像B树那样，B树并不是只有最后一行会存储卫星数据，此时比较凌乱。因为只有最后一行存储卫星数据，使用B+树，同样大小的磁盘页可以容纳更多的节点元素，这就意味着，数据量相同的情况下B+树比B树高度更低，减小磁盘IO的次数。其次，B+树的查询必须最终查找到叶子节点，而B树做的是值匹配，到达结点之后并不一定能够匹配成功，所以B树的查找性能并不稳定，最好的情况是只查根节点即可，而最坏的情况则需要查到叶子节点，但是B+树每一次查找都是稳定的，因为一定在叶子结点。</p><p>并且得益于最后一行的链表结构，B+树在做范围查询时性能突出。很多数据库都在采用B+树作为底层数据结构，比如MySQL就默认选择B+Tree作为索引的存储数据结构。</p><p>至此，有关B树和B+树相关内容，就到这里。</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>最后我们来介绍一个比较重要的的树形结构，在开篇之前，我想问下，各位了解文件压缩吗？它是怎么做到的呢？我们都会在这一节进行探讨。</p><blockquote><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树（Huffman Tree）</p></blockquote><p>乍一看好像没看懂，啥叫带权路径长度达到最小？就是树中所有的叶结点的权值乘上其到根结点根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）</p><p><img src="https://s2.loli.net/2022/08/17/goKnFtErpiNQebU.png" alt="image-20220817170310064"></p><p>这里我们分别将叶子结点ABCD都赋予一个权值，我们来尝试计算一下，计算公式如下：<br>$$<br>WPL &#x3D; \sum_{i&#x3D;1}^{n} (value(i) \times depth(i))<br>$$<br>那么左右两边的计算结果为：</p><ul><li>左图： $WPL&#x3D;5\times2+7\times2+2\times2+13\times2&#x3D;54$</li><li>右图：$WPL&#x3D;5\times3+2\times3+7\times2+13\times1&#x3D;48$</li></ul><p>通过计算结果可知，右图的带权路径长度最小，实际上右图是一棵哈夫曼树。</p><p>那么现在给了我们这些带权的叶子结点，我们怎么去构建一颗哈夫曼树呢？首先我们可以将这些结点视为4棵树，他们共同构成了一片森林：</p><p><img src="https://s2.loli.net/2022/08/17/V1E4tZsnGbWFzjo.png" alt="image-20220817171759738"></p><p>首先我们选择两棵权值最小的树作为一颗新的树的左右子树，左右顺序不重要（因为哈夫曼编码不唯一，后面会说），得到的树根结点权值为这两个结点之和：</p><p><img src="https://s2.loli.net/2022/08/17/ZCyj1PVwsqiWz4e.png" alt="image-20220817172343786"></p><p>接着，我们需要将这这棵树放回到森林中，重复上面的操作，继续选择两个最小的出来组成一颗新的树，此时得到：</p><p><img src="https://s2.loli.net/2022/08/17/G5EyArvMhJ9CQNS.png" alt="image-20220817172640686"></p><p>继续重复上述操作，直到森林里面只剩下一棵树为止：</p><p><img src="https://s2.loli.net/2022/08/17/ywuA6pRPrboE51S.png" alt="image-20220817172737480"></p><p>这样，我们就得到了一棵哈夫曼树，因为只要保证越大的值越靠近根结点，那么出来的一定是哈夫曼树。所以，我们辛辛苦苦把这棵树构造出来干嘛呢？实际上哈夫曼树的一个比较重要应用就是对数据进行压缩，它是现代压缩算法的基础，我们常常可以看到网上很多文件都是以压缩包（.zip、.7z、.rar等格式）形式存在的，我们将文件压缩之后。</p><p>比如这一堆字符串：ABCABCD，现在我们想要将其进行压缩然后保存到硬盘上，此时就可以使用哈夫曼编码。那么怎么对这些数据进行压缩呢？这里我们就可以采用刚刚构建好的哈夫曼树，我们需要先对其进行标注：</p><p><img src="https://s2.loli.net/2022/08/17/oRuOayXEKFkPs3d.png" alt="image-20220817173559604"></p><p>向左走是0，向右走是1，比如现在我们要求出A的哈夫曼编码，那么就是根结点到A整条路径上的值拼接：</p><ul><li>A：110</li><li>B：0</li><li>C：111</li><li>D：10</li></ul><p>这些编码看起来就像二进制的一样，也便于我们计算机的数据传输和保存，现在我们要对上面的这个字符串进行压缩，那么只需要将其中的每一个字符翻译为对应编码就行了：</p><ul><li>ABCABCD &#x3D; 110 0 111 110 0 111 10</li></ul><p>这样我们就得到了一堆压缩之后的数据了。那怎么解码回去呢，也很简单，只需要对照着写回去就行了：</p><ul><li>110 0 111 110 0 111 10 &#x3D; ABCABCD</li></ul><p>我们来尝试编写一下代码实现一下哈夫曼树的构建和哈夫曼编码的获取把，因为构建哈夫曼树需要选取最小的两个结点，这里需要使用到优先级队列。</p><p>优先级队列与普通队列不同，它允许VIP插队（权值越大的元素优先排到前面去），当然出队还是一律从队首出来。</p><p><img src="https://s2.loli.net/2022/08/17/xySEK5OZ8Q3IbNz.png" alt="image-20220817174835425"></p><p>比如一开始4和9排在队列中，这时又来了个7，那么由于7比4大，所以说可以插队，直接排到4的前面去，但是由于9比7大，所以说不能再往前插队了：</p><p><img src="https://s2.loli.net/2022/08/17/bv4cD8GTgo2qPEQ.png" alt="image-20220817174921980"></p><p>这就是优先级队列，VIP插队机制，要实现这样的优先级队列，我们只需要修改一下入队操作即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    LNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//因为下面用到了判断结点的下一个为NULL，所以说记得默认设定为NULL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, T element)</span>&#123;</span><br><span class="line">    LNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//因为下面用到了判断结点的下一个为NULL，所以说记得默认设定为NULL</span></span><br><span class="line">    LNode pre = <span class="built_in">queue</span>-&gt;front;   <span class="comment">//我们从头结点开始往后挨个看，直到找到第一个小于当前值的结点，或者到头为止</span></span><br><span class="line">    <span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;element &gt;= element)</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="built_in">queue</span>-&gt;rear) &#123;   <span class="comment">//如果说找到的位置已经是最后了，那么直接插入就行，这里跟之前是一样的</span></span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//否则开启VIP模式，直接插队</span></span><br><span class="line">        node-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">9</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">4</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">7</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">3</span>);</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/17/cw6QCUSgDjotKbl.png" alt="image-20220817180127650"></p><p>这样我们就编写好了一个优先级队列，然后就可以开始准备构建哈夫曼树了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">right</span>;</span></span><br><span class="line">    <span class="type">int</span> value;    <span class="comment">//存放权值</span></span><br><span class="line">&#125; * Node;</span><br></pre></td></tr></table></figure><p>首先按照我们前面的例子，构建出这四个带权值的结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">createNode</span><span class="params">(E element, <span class="type">int</span> value)</span>&#123;   <span class="comment">//创建一个结点</span></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, T element)</span>&#123;</span><br><span class="line">    LNode node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">  node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    LNode pre = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">while</span> (pre-&gt;next &amp;&amp; pre-&gt;next-&gt;element-&gt;value &lt;= element-&gt;value)   <span class="comment">//注意这里改成权重的比较，符号改成小于</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(pre == <span class="built_in">queue</span>-&gt;rear) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = node;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;A&#x27;</span>, <span class="number">5</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;B&#x27;</span>, <span class="number">16</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;C&#x27;</span>, <span class="number">8</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;D&#x27;</span>, <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/17/IU9RYEVl7GytZmQ.png" alt="image-20220817180820954"></p><p>已经是按照权重顺序在排队了，接着我们就可以开始构建哈夫曼树了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;A&#x27;</span>, <span class="number">5</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;B&#x27;</span>, <span class="number">16</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;C&#x27;</span>, <span class="number">8</span>));</span><br><span class="line">    offerQueue(&amp;<span class="built_in">queue</span>, createNode(<span class="string">&#x27;D&#x27;</span>, <span class="number">13</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">queue</span>.front-&gt;next != <span class="built_in">queue</span>.rear) &#123;   <span class="comment">//如果front的下一个就是rear那么说明队列中只有一个元素了</span></span><br><span class="line">        Node left = pollQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">        Node right = pollQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">        Node node = createNode(<span class="string">&#x27; &#x27;</span>, left-&gt;value + right-&gt;value);   <span class="comment">//创建新的根结点</span></span><br><span class="line">        node-&gt;left = left;</span><br><span class="line">        node-&gt;right = right;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, node);   <span class="comment">//最后将构建好的这棵树入队</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node root = pollQueue(&amp;<span class="built_in">queue</span>);   <span class="comment">//最后出来的就是哈夫曼树的根结点了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在得到哈夫曼树之后，我们就可以对这些字符进行编码了，当然注意我们这里面只有ABCD这几种字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">encode</span><span class="params">(Node root, E e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//为NULL肯定就是没找到</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;element == e) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;   <span class="comment">//如果找到了就返回一个空串</span></span><br><span class="line">    <span class="type">char</span> * str = encode(root-&gt;left, e);  <span class="comment">//先去左边找</span></span><br><span class="line">    <span class="type">char</span> * s = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s[<span class="number">0</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        str = <span class="built_in">strcat</span>(s, str);   <span class="comment">//如果左边找到了，那么就把左边的已经拼好的字符串拼接到当前的后面</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//左边不行那再看看右边</span></span><br><span class="line">        str = encode(root-&gt;right, e);</span><br><span class="line">        <span class="keyword">if</span>(str != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s[<span class="number">0</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            str = <span class="built_in">strcat</span>(s, str);   <span class="comment">//如果右边找到了，那么就把右边的已经拼好的字符串拼接到当前的后面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;   <span class="comment">//最后返回操作好的字符串给上一级</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printEncode</span><span class="params">(Node root, E e)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c 的编码为：%s&quot;</span>, e, encode(root, e));   <span class="comment">//编码的结果就是了</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    Node root = pollQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    printEncode(root, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    printEncode(root, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    printEncode(root, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    printEncode(root, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功得到对应的编码：</p><p><img src="https://s2.loli.net/2022/08/17/zx2cXns73yQThaV.png" alt="image-20220817184746630"></p><h3 id="堆和优先级队列"><a href="#堆和优先级队列" class="headerlink" title="堆和优先级队列"></a>堆和优先级队列</h3><p>前面我们在讲解哈夫曼树时了解了优先级队列，它提供一种可插队的机制，允许权值大的结点排到前面去，但是出队顺序还是从队首依次出队。我们通过对前面的队列数据结构的插入操作进行改造，实现了优先级队列。</p><p>这节课我们接着来了解一下<strong>堆</strong>（Heap）它同样可以实现优先级队列。</p><p>首先必须是一棵完全二叉树，树中父亲都比孩子小的我们称为<strong>小根堆</strong>（小顶堆），树中父亲都比孩子大则是<strong>大根堆</strong>（注意不要跟二叉查找树搞混了，二叉查找树是左小右大，而堆只要是孩子一定小或者大），它是一颗具有特殊性质的完全二叉树。比如下面就是一个典型的大根堆：</p><p><img src="https://s2.loli.net/2022/08/18/1ULKRiAeZcI2hJm.png" alt="image-20220818104754776"></p><p>因为完全二叉树比较适合使用数组才存储（因为是按序的）所以说一般堆都是以数组形式存放：</p><p><img src="https://s2.loli.net/2022/08/18/XpYVN2gslOfWLSr.png" alt="image-20220818110224673"></p><p>那么它是怎么运作的呢？比如现在我们想要往堆中插入一个新的元素8，那么：</p><p><img src="https://s2.loli.net/2022/08/18/mcq2wjLvxHUu6R7.png" alt="image-20220818110450863"></p><p> 因为是一棵完全二叉树，那么必须按照顺序，继续在当前这一行从左往右插入新的结点，其实就相当于在数组的后面继续加一个新的进来，是一样的。但是因为要满足大顶堆的性质，所以此时8加入之后，破坏了规则，我们需要进行对应的调整（堆化），很简单，我们只需要将其与父结点交换即可：</p><p><img src="https://s2.loli.net/2022/08/18/T187nAaRBV9jJed.png" alt="image-20220818110835798"></p><p>同样的，数组的形式的话，我们就行先计算出它的父结点，然后进行交换即可：</p><p><img src="https://s2.loli.net/2022/08/18/tp81Tlr6LzFeaXQ.png" alt="image-20220818111156209"></p><p>当然，还没完，我们还需要继续向上比较，直到稳定为止，此时7依然是小于8的，所以说需要继续交换：</p><p><img src="https://s2.loli.net/2022/08/18/FP5LhdDZ9zVBYfl.png" alt="image-20220818111311322"></p><p>现在满足性质了，堆化结束，可以看到最大的元素被排到了最前面，这不就是我们前面的优先级队列吗。</p><p>现在我们来试试看删除队首元素，也就相当于出队操作，删除最顶上的元素：</p><p><img src="https://s2.loli.net/2022/08/18/XxivcLFwebrUKf2.png" alt="image-20220818111840303"></p><p>现在需要删除最顶上的元素但是我们需要保证删除之后依然是一棵完全二叉树，所以说我们先把排在最后面的拿上来顶替一下：</p><p><img src="https://s2.loli.net/2022/08/18/MmtNHQla3zej6FC.png" alt="image-20220818111959046"></p><p><img src="https://s2.loli.net/2022/08/18/OWGiYxKb71o249T.png" alt="image-20220818112109066"></p><p>接着我们需要按照与插入相反的方向，从上往下进行堆化操作，规则是一样的，遇到大的就交换，直到不是为止：</p><p><img src="https://s2.loli.net/2022/08/18/BqTkxDov8AXtwCZ.png" alt="image-20220818112222696"></p><p>这样，我们发现，即使完成了出队操作，依然是最大的元素排在队首，并且整棵树依然是一棵完全二叉树。</p><p>按照上面的操作，我们来编写一下代码吧，这里还是以大顶堆为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MaxHeap</span> &#123;</span></span><br><span class="line">    E * arr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">&#125; * Heap;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initHeap</span><span class="params">(Heap heap)</span>&#123;   <span class="comment">//初始化都是老套路了，不多说了</span></span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    heap-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    heap-&gt;arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (E) * heap-&gt;capacity);</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;arr != <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MaxHeap</span> <span class="title">heap</span>;</span></span><br><span class="line">    initHeap(&amp;heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是插入操作，首先还是需要判断是否已满：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insert</span><span class="params">(Heap heap, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(heap-&gt;size == heap-&gt;capacity) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//满了就不处理了，主要懒得写扩容了</span></span><br><span class="line">    <span class="type">int</span> index = ++heap-&gt;size;   <span class="comment">//先计算出要插入的位置，注意要先自增，因为是从1开始的</span></span><br><span class="line">    <span class="comment">//然后开始向上堆化，直到符合规则为止</span></span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; element &gt; heap-&gt;arr[index / <span class="number">2</span>]) &#123;</span><br><span class="line">        heap-&gt;arr[index] = heap-&gt;arr[index / <span class="number">2</span>];</span><br><span class="line">        index /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在得到的index就是最终的位置了</span></span><br><span class="line">    heap-&gt;arr[index] = element;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printHeap</span><span class="params">(Heap heap)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= heap-&gt;size; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, heap-&gt;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MaxHeap</span> <span class="title">heap</span>;</span></span><br><span class="line">    initHeap(&amp;heap);</span><br><span class="line">    insert(&amp;heap, <span class="number">5</span>);</span><br><span class="line">    insert(&amp;heap, <span class="number">2</span>);</span><br><span class="line">    insert(&amp;heap, <span class="number">3</span>);</span><br><span class="line">    insert(&amp;heap, <span class="number">7</span>);</span><br><span class="line">    insert(&amp;heap, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    printHeap(&amp;heap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果为：</p><p><img src="https://s2.loli.net/2022/08/18/bFS9KEPNxRdnYas.png" alt="image-20220818120554099"></p><p>插入完成之后，我们接着来写一下删除操作，删除操作实际上就是出队的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">delete</span><span class="params">(Heap heap)</span>&#123;</span><br><span class="line">    E max = heap-&gt;arr[<span class="number">1</span>], e = heap-&gt;arr[heap-&gt;size--];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index * <span class="number">2</span> &lt;= heap-&gt;size) &#123;   <span class="comment">//跟上面一样，开找，只不过是从上往下找</span></span><br><span class="line">        <span class="type">int</span> child = index * <span class="number">2</span>;   <span class="comment">//先找到左孩子</span></span><br><span class="line">        <span class="comment">//看看右孩子和左孩子哪个大，先选一个大的出来</span></span><br><span class="line">        <span class="keyword">if</span>(child &lt; heap-&gt;size &amp;&amp; heap-&gt;arr[child] &lt; heap-&gt;arr[child + <span class="number">1</span>])</span><br><span class="line">            child += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(e &gt;= heap-&gt;arr[child]) <span class="keyword">break</span>;   <span class="comment">//如果子结点都不大于新结点，那么说明就是这个位置，结束就行了</span></span><br><span class="line">        <span class="keyword">else</span> heap-&gt;arr[index] = heap-&gt;arr[child];  <span class="comment">//否则直接堆化，换上去</span></span><br><span class="line">        index = child;   <span class="comment">//最后更新一下index到下面去</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;arr[index] = e;   <span class="comment">//找到合适位置后，放进去就行了</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MaxHeap</span> <span class="title">heap</span>;</span></span><br><span class="line">    initHeap(&amp;heap);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, delete(&amp;heap));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/08/18/x8YDojfnp2yBqvA.png" alt="image-20220818120633714"></p><p>可以看到结果就是优先级队列的出队结果，这样，我们就编写好了大顶堆的插入和删除操作了。</p><p>当然，堆在排序上也有着非常方便的地方，在后面的排序算法篇中，我们还会再次说起它。</p><p>至此，有关树形结构篇的内容，我们就全部讲解完毕了，请务必认真掌握前面的二叉树和高级二叉树结构，这些都是重点内容，下一章我们将继续探讨<strong>散列表</strong>。</p><hr><h2 id="算法实战"><a href="#算法实战" class="headerlink" title="算法实战"></a>算法实战</h2><p>二叉树相关的算法实战基本都是与递归相关的，因为它实在是太适合用分治算法了！</p><h3 id="（简单）二叉查找树的范围和"><a href="#（简单）二叉查找树的范围和" class="headerlink" title="（简单）二叉查找树的范围和"></a>（简单）二叉查找树的范围和</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></p><p>给定<strong>二叉搜索树</strong>的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。</p><p>示例 1：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt="img"></p><p>输入：root &#x3D; [10,5,15,3,7,null,18], low &#x3D; 7, high &#x3D; 15   （注意力扣上的输入案例写的是层序序列，含空节点）<br>输出：32</p></blockquote><p>示例 2：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" alt="img"></p><p>输入：root &#x3D; [10,5,15,3,7,13,18,1,null,6], low &#x3D; 6, high &#x3D; 10<br>输出：23</p></blockquote><p>这道题其实就是考察我们对于二叉查找树的理解，利用二叉查找树的性质，这道题其实很简单，只需要通过递归分治就可以解决了。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; high)    <span class="comment">//如果最大的值都比当前结点值小，那么肯定在左边才能找到</span></span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; low)   <span class="comment">//如果最小值都比当前结点大，那么肯定在右边才能找到</span></span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;right, low, high);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//这种情况肯定是在范围内了，将当前结点值加上左右的，再返回</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + rangeSumBST(root-&gt;right, low, high) + rangeSumBST(root-&gt;left, low, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种问题比较简单，直接四行就解决了。</p><hr><h3 id="（中等）重建二叉树"><a href="#（中等）重建二叉树" class="headerlink" title="（中等）重建二叉树"></a>（中等）重建二叉树</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>示例 1:</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><p>Input: preorder &#x3D; [3,9,20,15,7], inorder &#x3D; [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p></blockquote><p>示例 2:</p><blockquote><p>Input: preorder &#x3D; [-1], inorder &#x3D; [-1]<br>Output: [-1]</p></blockquote><p>实际上这道题就是我们前面练习题的思路，现在给到我们的是前序和中序遍历的结果，我们只需要像之前一样逐步推导即可。</p><p>在中序遍历序列中找到根节点的位置后，这个问题就很好解决了，大致思路如下：</p><ol><li>由于前序遍历首元素为根节点值，首先可以得到根节点值。</li><li>在中序遍历序列中通过根节点的值，寻找根节点的位置。</li><li>将左右两边的序列分割开来，并重构为根节点的左右子树。（递归分治）</li><li>在新的序列中，重复上述步骤，通过前序遍历再次找到当前子树的根节点，再次进行分割。</li><li>直到分割到仅剩下一个结点时，开始回溯，从而完成整棵二叉树的重建。</li></ol><p>解题代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode * <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;   <span class="comment">//这个就是单纯拿来创建结点的函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">node</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心递归分治实现</span></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTreeCore</span><span class="params">(<span class="type">int</span> * preorder, <span class="type">int</span> * inorder, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//如果都超出范围了，肯定不行</span></span><br><span class="line">    <span class="keyword">if</span>(start == end) <span class="keyword">return</span> createNode(preorder[index]);   <span class="comment">//如果已经到头了，那么直接创建结点返回即可</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">node</span> =</span> createNode(preorder[index]);   <span class="comment">//先从前序遍历中找到当前子树的根结点值，然后创建对应的结点</span></span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">while</span> (inorder[pos] != preorder[index]) pos++;   <span class="comment">//找到中序的对应位置，从这个位置开始左右划分</span></span><br><span class="line">    node-&gt;left = buildTreeCore(preorder, inorder, start, pos - <span class="number">1</span>, index+<span class="number">1</span>);   </span><br><span class="line">  <span class="comment">//当前结点的左子树按照同样的方式建立</span></span><br><span class="line">  <span class="comment">//因为前序遍历的下一个结点就是左子树的根结点，所以说这里给index+1</span></span><br><span class="line">    node-&gt;right = buildTreeCore(preorder, inorder, pos+<span class="number">1</span>, end, index+(pos-start)+<span class="number">1</span>);  </span><br><span class="line">  <span class="comment">//当前结点的右子树按照同样的方式建立</span></span><br><span class="line">  <span class="comment">//最后一个index需要先跳过左子树的所有结点，才是右子树的根结点，所以说这里加了个pos-start，就是中序划分出来，左边有多少就减去多少</span></span><br><span class="line">    <span class="keyword">return</span> node;   <span class="comment">//向上一级返回当前结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>* preorder, <span class="type">int</span> preorderSize, <span class="type">int</span>* inorder, <span class="type">int</span> inorderSize)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildTreeCore(preorder, inorder, <span class="number">0</span>, preorderSize - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//这里传入了前序和中序序列，并且通过start和end指定当前中序序列的处理范围，最后的一个index是前序遍历的对应头结点位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="（中等）验证二叉搜索树"><a href="#（中等）验证二叉搜索树" class="headerlink" title="（中等）验证二叉搜索树"></a>（中等）验证二叉搜索树</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>（先说，这题老六行为过多，全站通过率只有36.5%，但是题目本身很简单）</p><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><p>示例 1：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><p>输入：root &#x3D; [2,1,3]<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><p>输入：root &#x3D; [5,1,4,null,null,3,6]<br>输出：false<br>解释：根节点的值是 5 ，但是右子节点的值是 4 。</p></blockquote><p>这种题看起来好像还挺简单的，我们可以很快地写出代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//到头了就直接返回真</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;val &gt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//如果左边不是空，并且左边还比当前结点值小的话，那肯定不是了</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; root-&gt;right-&gt;val &lt;= root-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root-&gt;left) &amp;&amp; isValidBST(root-&gt;right);  <span class="comment">//接着向下走继续判断左右两边子树，必须同时为真才是真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接上力扣测试，嗯，没问题，提交，这把必过！于是光速打脸：</p><p><img src="https://s2.loli.net/2022/08/17/EQdvDtlnSgU7kWC.png" alt="image-20220817224437688"></p><p>不可能啊，我们的逻辑判断没有问题的，我们的算法不可能被卡的啊？（这跟我当时打ACM一样的感觉，我这天衣无缝的算法不可能错的啊，哪个老六测试用例给我卡了）这其实是因为我们没有考虑到右子树中左子树比根结点值还要小的情况：</p><p><img src="https://s2.loli.net/2022/08/17/AjU1G2nXytRCKoW.png" alt="image-20220817224830911"></p><p>虽然这样错的很明显，但是按照我们上面的算法，这种情况确实也会算作真。所以说我们需要改进一下，对其上界和下界进行限定，不允许出现这种低级问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">long</span> min, <span class="type">long</span> max)</span>&#123;   <span class="comment">//这里上界和下界用long表示，因为它的范围给到整个int，真是个老六</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//这里还需要判断是否正常高于下界</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span> &amp;&amp; (root-&gt;left-&gt;val &gt;= root-&gt;val || root-&gt;left-&gt;val &lt;= min))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//这里还需判断一下是否正常低于上界</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span> &amp;&amp; (root-&gt;right-&gt;val &lt;= root-&gt;val || root-&gt;right-&gt;val &gt;= max))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValid(root-&gt;left, min, root-&gt;val) &amp;&amp; isValid(root-&gt;right, root-&gt;val, max);</span><br><span class="line">    <span class="comment">//注意往左走更新上界，往右走更新下界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValidBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isValid(root, <span class="number">-2147483649</span>, <span class="number">2147483648</span>);   <span class="comment">//下界刚好比int少1，上界刚好比int多1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就没问题了。</p><hr><h3 id="（中等）求根到叶数字之和"><a href="#（中等）求根到叶数字之和" class="headerlink" title="（中等）求根到叶数字之和"></a>（中等）求根到叶数字之和</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></p><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。<br>每条从根节点到叶节点的路径都代表一个数字：</p><p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p><p>叶节点 是指没有子节点的节点。 </p><p>示例 1：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="img"></p><p>输入：root &#x3D; [1,2,3]<br>输出：25<br>解释：<br>从根到叶子节点路径 1-&gt;2 代表数字 12<br>从根到叶子节点路径 1-&gt;3 代表数字 13<br>因此，数字总和 &#x3D; 12 + 13 &#x3D; 25</p></blockquote><p>示例 2：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg" alt="img"></p><p>输入：root &#x3D; [4,9,0,5,1]<br>输出：1026<br>解释：<br>从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495<br>从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491<br>从根到叶子节点路径 4-&gt;0 代表数字 40<br>因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</p></blockquote><p>这道题其实也比较简单，直接从上向下传递当前路径上已经组装好的值即可，到底时返回最终的组装结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumNumbersImpl</span><span class="params">(<span class="keyword">struct</span> TreeNode * root, <span class="type">int</span> parent)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果到头了，直接返回0</span></span><br><span class="line">  <span class="type">int</span> sum = root-&gt;val + parent * <span class="number">10</span>;   <span class="comment">//因为是依次向后拼接，所以说直接将之前的值x10然后加上当前值即可</span></span><br><span class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)    <span class="comment">//如果是叶子结点，那么直接返回结果</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">  <span class="comment">//否则按照同样的方式将左右的结果加起来</span></span><br><span class="line">    <span class="keyword">return</span> sumNumbersImpl(root-&gt;left, sum) + sumNumbersImpl(root-&gt;right,  sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sumNumbersImpl(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="（困难）结点之和的最大路径"><a href="#（困难）结点之和的最大路径" class="headerlink" title="（困难）结点之和的最大路径"></a>（困难）结点之和的最大路径</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/jC7MId/">剑指 Offer II 051. 节点之和最大的路径</a>（这是一道Hard难度的题目，但是其实还好）</p><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值。</p><p>示例 1：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><p>输入：root &#x3D; [1,2,3]<br>输出：6<br>解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 &#x3D; 6</p></blockquote><p>示例 2：</p><blockquote><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><p>输入：root &#x3D; [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 &#x3D; 42</p></blockquote><p>首先，我们要知道，路径有很多种可能，要么从上面下来，要么从左边上来往右边走，要么只走右边，要么只走左边…我们需要寻找一个比较好的方法在这么多种可能性之间选择出最好的那一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">-2147483648</span>;    <span class="comment">//使用一个全局变量来存储一下当前的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//不想多说了</span></span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//先把左右两边走或是不走的情况计算一下，取出值最大的情况</span></span><br><span class="line">    <span class="type">int</span> leftMax = max(maxValue(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> rightMax = max(maxValue(root-&gt;right), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//因为要么只走左边，要么只走右边，要么左右都走，所以说我们计算一下最大情况下的结果</span></span><br><span class="line">    <span class="type">int</span> maxTmp = leftMax + rightMax + root-&gt;val;</span><br><span class="line">    result = max(maxTmp, result);   <span class="comment">//更新一下最大值</span></span><br><span class="line">    <span class="comment">//然后就是从上面下来的情况了，从上面下来要么左要么右，此时我们只需要返回左右最大的一个就行了</span></span><br><span class="line">    <span class="keyword">return</span> max(leftMax, rightMax) + root-&gt;val;  <span class="comment">//注意还要加上当前结点的值，因为肯定要经过当前结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span>&#123;</span><br><span class="line">    maxValue(root);</span><br><span class="line">    <span class="keyword">return</span> result;   <span class="comment">//最后返回完事之后最终得到的最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就成功解决了这种问题。</p><p>此文章为搬运！！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构（1）</title>
    <link href="http://yoursite.com/post/6dfa245.html"/>
    <id>http://yoursite.com/post/6dfa245.html</id>
    <published>2022-11-11T16:16:30.000Z</published>
    <updated>2022-11-11T16:29:20.437Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://s2.loli.net/2022/07/09/otEZIiDc3WX9h4f.png" alt="image-20220709170114962"></p><h1 id="线性结构篇"><a href="#线性结构篇" class="headerlink" title="线性结构篇"></a>线性结构篇</h1><p><strong>注意：</strong>开始本篇学习之前，请确保你完成了 <strong>C语言程序设计</strong> 篇视频教程，否则无法进行学习。</p><p>我们本系列课程分为基础知识和算法实战两部分，其中算法实战在LeetCode上进行：<a href="https://leetcode.cn/%EF%BC%8C%E5%90%84%E4%BD%8D%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%89%8D%E5%9C%A8%E5%B9%B3%E5%8F%B0%E4%B8%8A%E6%B3%A8%E5%86%8C%E5%A5%BD%E7%9B%B8%E5%85%B3%E8%B4%A6%E5%8F%B7%E3%80%82">https://leetcode.cn/，各位可以提前在平台上注册好相关账号。</a></p><p>学习完数据结构，各位小伙伴可以尝试参加算法相关的学科竞赛，如ICPC-ACM、蓝桥杯等，算法类的比赛含金量相比项目类比赛更高，也更有价值，相应的，算法类竞赛难道会更大一些，尤其是ICPC-ACM大学生程序设计竞赛，一般都是各个高校内顶尖级队伍进行参赛，甚至还有中学队伍（这类学生预定清华、北大），因为算法更加考验个人的思维能力和天赋水平，相比其他计算机基础课程，数据结构和算法是难度最高的，也是各大高校考研的重点内容。</p><p>不过虽然很难，并且考验个人天赋，但是大部分人通过努力学习是完全能够掌握基础部分的，在应对80%的题目时，是完全有机会解决的，所以，不要怀疑自己，说不定你就是下一个大佬。</p><p>这里也说一下面试推荐书籍，内含多种常用算法以及解题分析，值得一看：</p><p><img src="https://s2.loli.net/2022/07/09/TurKEpDHmvlgJhZ.png" alt="image-20220709170248015"></p><p>本篇内容虽然继续以C语言为基础进行讲解，但是将不再涉及到C语言的语言层面相关内容，更多的是数据结构和算法的思想，实际上用任意一种语言都可以实现。</p><hr><h2 id="什么是数据结构与算法"><a href="#什么是数据结构与算法" class="headerlink" title="什么是数据结构与算法"></a>什么是数据结构与算法</h2><p>回顾我们之前的C语言程序设计阶段，我们已经接触过基本数据类型，并且能够使用结构体对数据进行组织，我们可以很轻松地使用一个结构体来存放一个学生的完整数据，在数据结构学习阶段，我们还会进一步地研究。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>那么，我们来看看，什么是数据结构呢？</p><blockquote><p> 数据结构(data structure)是带有结构特性的数据元素的集合，它研究的是数据的<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84/9663235">逻辑结构</a>和数据的物理结构以及它们之间的相互关系。</p></blockquote><p>比如现在我们需要保存100个学生的数据，那么你首先想到的肯定是使用数组吧！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果我们现在有了新的需求呢？我们不仅仅是存放这些数据，我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。</p><p><img src="https://s2.loli.net/2022/07/10/9RwL7pxgyfoB3WT.png" alt="image-20220710103307583"></p><p>我们需要一种更好的数据表示和组织方式，才能做到类似于增删改查这样的操作，而完成这些操作所用到的方法，我们称其为“算法”，所以数据结构和算法，一般是放在一起进行讲解的。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>比如现在我们希望你求出1-100所有数字的和，请通过程序来实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; ++i) sum += i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很容易就能编写出这样的程序，实际上只需要一个for循环就能搞定了，而这就是我们设计的算法。</p><p><img src="https://s2.loli.net/2022/07/09/srPn4baDXWZ9qcJ.png" alt="image-20220709223103628"></p><p>在之前的C语言程序设计阶段，我们其实已经学习了许多算法，包括排序算法、动态规划等。</p><p>当然，解决问题的算法并不是只有一种，实际上我们上面的方式并不是最优的算法，如果想要求得某一段整数的和，其实使用<strong>高斯求和公式</strong>能够瞬间得到结果：<br>$$<br>\sum&#x3D;\frac{(首项+末项)\times项数}{2}<br>$$<br>所以，我们完全没必要循环那么多次进行累加计算，而是直接使用数学公式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="number">1</span> + <span class="number">100</span>) * <span class="number">100</span> / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，算法的尽头还得是数学啊。</p><p>可见，不同的算法，执行的效率也是有很大差别的，这里我们就要提到算法的复杂度了。衡量一个算法的复杂程度需要用到以下两个指标：</p><ul><li>时间复杂度<code>T(n)</code>：算法程序在执行时消耗的时间长度，一般与输入数据的规模n有关。</li><li>空间复杂度<code>S(n)</code>：算法程序在执行时占用的存储单元长度，同样与数据的输入规模n有关，大部分情况下，我们都是采取空间换时间的算法。</li></ul><p>比如我们上面的两种算法，第一种需要执行n次循环，每轮循环进行一次累加操作，而第二种只需要进行一次计算即可。实际中我们计算时间复杂度时，其实并不一定要计算精确的执行次数，而只需要大概执行次数，那么这里我们使用<code>O</code>渐进表示法。</p><ul><li><strong>大O符号（Big O notation）</strong>：是用于描述函数渐进行为的数学符号。</li></ul><p>而这里的循环次数，实际上就是我们需要知道的大致执行次数，所以第一种算法的时间复杂度为：<code>O(n)</code>，其中n就是项数，因为它需要执行n次计算才能得到最后的结果。而第二种算法的时间复杂度为：<code>O(1)</code>，因为它只需要执行一次计算（更准确的说它的执行次数是一个常数，跟项数n毫无关系），显然，当n变得非常大时，第二种方法的计算速度远超第一种。</p><p>再比如我们之前使用的冒泡排序算法，需要进行两轮循环，而循环的次数在经过优化之后为<code>(n - 1)(n - 1)/2</code>，得到的结果中包含了一个<code>n</code>的平方，此时这种算法的时间复杂度就来到<code>O(n^2)</code>了。</p><p>在不同的空间复杂度下，可能n小的时候还没什么感觉，但是当n变得非常大时，差距就不是一点半点了，我们来看看常用函数的增长曲线：</p><p><img src="https://s2.loli.net/2022/07/09/Tr6jI5uPzy2NeDd.png" alt="image-20220709230756755"></p><p>所以我们在设计算法的时候，一定要考虑到时间和空间复杂度的问题，这里列出常用函数的增长表：</p><table><thead><tr><th align="center">函数</th><th align="center">类型</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">$\Omicron(1)$</td><td align="center">常数阶</td><td align="center">如果算法能够优化到这个程度，那么基本上算是最快的算法了。</td></tr><tr><td align="center">$\Omicron(\log_{2}n)$</td><td align="center">对数阶</td><td align="center">仅次于常数阶的速度，我们后面会介绍的二分搜索算法，就能够到达这个级别。</td></tr><tr><td align="center">$\Omicron(n)$</td><td align="center">线性阶</td><td align="center">我们后面介绍的线性表插入、删除数据，包括动态规划类算法能够达到线性阶。</td></tr><tr><td align="center">$\Omicron(n\log_{2}n)$</td><td align="center">线性对数阶</td><td align="center">相当于在对数阶算法外层套了一层线性阶循环。</td></tr><tr><td align="center">$\Omicron(n^2)$</td><td align="center">平方阶</td><td align="center">我们前面学习的冒泡排序，需要进行两重循环，实际上就是平方阶。</td></tr><tr><td align="center">$\Omicron(n^3)$</td><td align="center">立方阶</td><td align="center">从立方阶开始，时间复杂度就开始变得有点大了。</td></tr><tr><td align="center">$\Omicron(2^n)$</td><td align="center">指数阶</td><td align="center">我们前面介绍的斐波那契数列递归算法，就是一个指数阶的算法，因为它包含大量的重复计算。</td></tr><tr><td align="center">$\Omicron(n!)$</td><td align="center">阶乘</td><td align="center">这个增长速度比指数阶还恐怖，但是一般很少有算法能达到这个等级。</td></tr></tbody></table><p>我们在编写算法时，一定要注意算法的时间复杂度，当时间复杂度太大时，可能计算机就很难在短时间内计算出结果了。</p><h3 id="案例：二分搜索算法"><a href="#案例：二分搜索算法" class="headerlink" title="案例：二分搜索算法"></a>案例：二分搜索算法</h3><p>现在有一个从小到大排序的数组，给你一个目标值<code>target</code>，现在请你找到这个值在数组中的对应下标，如果没有，请返回<code>-1</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="comment">//请实现查找算法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;, target = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, search(arr, <span class="number">10</span>, target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，最简单的方法就是将数组中的元素一个一个进行遍历，总有一个是，如果遍历完后一个都没有，那么就结束：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == target) <span class="keyword">return</span> i;   <span class="comment">//循环n次，直到找到为止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样的算法简单粗暴，但是并不是最好的，我们需要遍历n次才能得到结果，时间复杂度为$\Omicron(n)$，我们可以尝试将其优化到更低的时间复杂度。这里我们利用它有序的特性，实际上当我们查找到大于目标<code>target</code>的数时，就没必要继续寻找了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == target) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样循环进行的次数也许就会减小了，但是如果我们要寻找的目标<code>target</code>刚好是最后几个元素呢？这时时间复杂度又来到到了$\Omicron(n)$，那么有没有更好的办法呢？我们依然可以继续利用数组有序的特性，既然是有序的，那么我们不妨随机在数组中找一个数，如果这个数大于目标，那么就不再考虑右边的部分，如果小于目标，那么就考虑左边的部分，然后继续在另一部分中再次随机找一个数，这样每次都能将范围缩小，直到找到为止（其思想就比较类似于<strong>牛顿迭代法</strong>，再次强调数学的重要性）</p><p><img src="https://s2.loli.net/2022/07/10/CczrjdlmBgPSRIb.png" alt="image-20220710095856681"></p><p>而二分思想就是将一个有序数组不断进行平分，直到找到为止，这样我们每次寻找的范围会不断除以2，所以查找的时间复杂度就降到了$\Omicron(\log_{2}n)$，相比一个一个比较，效率就高了不少：</p><p><img src="https://s2.loli.net/2022/07/10/FSDcHgG3sOo789z.png" alt="image-20220710101328777"></p><p>好了，那么现在我们就可以利用这种思想，编写出二分搜索算法了，因为每一轮都在进行同样的搜索操作，只是范围不一样，所以这里直接采用递归分治算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> * nums, <span class="type">int</span> target, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;  <span class="comment">//left代表左边界，right代表右边界</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//如果左边大于右边，那么肯定就找完了，所以直接返回</span></span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;   <span class="comment">//这里计算出中间位置</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;   <span class="comment">//直接比较，如果相等就返回下标</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid] &gt; target)    <span class="comment">//这里就是大于或小于的情况了，这里mid+1和mid-1很多人不理解，实际上就是在下一次寻找中不算上当前的mid，因为这里已经比较过了，所以说左边就-1，右边就+1</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, target, left, mid - <span class="number">1</span>);   <span class="comment">//如果大于，那么说明肯定不在右边，直接去左边找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, target, mid + <span class="number">1</span>, right);  <span class="comment">//如果小于，那么说明肯定不在左边，直接去右边找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch(nums, target, <span class="number">0</span>, numsSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以使用<code>while</code>循环来实现二分搜索，如果需要验证自己的代码是否有问题，可以直接在力扣上提交代码：<a href="https://leetcode.cn/problems/binary-search/">https://leetcode.cn/problems/binary-search/</a></p><hr><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>那么作为数据结构的开篇，我们就从最简单的线性表开始介绍。</p><p>还记得我们开篇提了一个问题吗？</p><blockquote><p>我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。</p></blockquote><p>数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List）</p><blockquote><p>线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。</p></blockquote><p>线性表一般需要包含以下功能：</p><ul><li><strong>初始化线性表：</strong>将一个线性表进行初始化，得到一个全新的线性表。</li><li><strong>获取指定位置上的元素：</strong>直接获取线性表指定位置<code>i</code>上的元素。</li><li><strong>获取元素的位置：</strong>获取某个元素在线性表上的位置<code>i</code>。</li><li><strong>插入元素：</strong>在指定位置<code>i</code>上插入一个元素。</li><li><strong>删除元素：</strong>删除指定位置<code>i</code>上的一个元素。</li><li><strong>获取长度：</strong>返回线性表的长度。</li></ul><p>也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表：</p><p><img src="https://s2.loli.net/2022/07/23/Ve6dlqROzhumD5o.png" alt="image-20220723112639416"></p><p>简单来说它就是列表，比如我们的菜单，我们在点菜时就需要往菜单列表中添加菜品或是删除菜品，这时列表就很有用了，因为数组长度固定、操作简单，而我们添加菜品、删除菜品这些操作又要求长度动态变化、操作多样。</p><p>那么，如此高级的数据结构，我们该如何去实现呢？实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。</p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>前面我们说到，既然数组无法实现这样的高级表结构，那么我就基于数组，对其进行强化，也就是说，我们存放数据还是使用数组，但是我们可以为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为顺序表。</p><p><img src="https://s2.loli.net/2022/07/24/elBvx4Zo1AJ2WqT.png" alt="image-20220724150015044"></p><p>这里我们可以先定义一个新的结构体类型，将一些需要用到的数据保存在一起，这里我们以<code>int</code>类型的线性表为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;  <span class="comment">//这里我们的元素类型就用int为例吧，先起个别名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E <span class="built_in">array</span>[<span class="number">10</span>];   <span class="comment">//实现顺序表的底层数组</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">//表示底层数组的容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了一会使用方便，我们可以给其起一个别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> * <span class="title">ArrayList</span>;</span> <span class="comment">//因为是数组实现，所以就叫ArrayList，这里直接将List的指针起别名</span></span><br></pre></td></tr></table></figure><p>然后我们就可以开始编写第一个初始化操作了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;   <span class="comment">//直接将数组的容量设定为10即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们发现一个问题，这样的话我们的顺序表长度不就是固定为10的了吗？而前面我们线性表要求的是长度是动态增长的，那么这个时候怎么办呢？我们可以直接使用一个指针来指向底层数组的内存区域，当装不下的时候，我们可以创建一个新的更大的内存空间来存放数据，这样就可以实现扩容了，所以我们来修改一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;   <span class="comment">//指向顺序表的底层数组</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">//数组的容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着我们修改一下初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;  <span class="comment">//这里就默认所有的顺序表初始大小都为10吧，随意</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);   <span class="comment">//使用malloc函数申请10个int大小的内存空间，作为底层数组使用</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;    <span class="comment">//容量同样设定为10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是还没完，因为我们的表里面，默认情况下是没有任何元素的，我们还需要一个变量来表示当前表中的元素数量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;   <span class="comment">//指向顺序表的底层数组</span></span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">//数组的容量</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">//表中的元素数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> * <span class="title">ArrayList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;  <span class="comment">//这里就默认所有的顺序表初始大小都为10吧，随意</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);   <span class="comment">//使用malloc函数申请10个int大小的内存空间，作为底层数组使用</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;    <span class="comment">//容量同样设定为10</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;   <span class="comment">//元素数量默认为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种情况我们需要考虑，也就是说如果申请内存空间失败，那么需要返回一个结果告诉调用者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//需要判断如果申请的结果为NULL的话表示内存空间申请失败</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//正常情况下返回true也就是1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个比较简单的顺序表就定义好，我们可以通过<code>initList</code>函数对其进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> <span class="title">list</span>;</span>   <span class="comment">//创建新的结构体变量</span></span><br><span class="line">    <span class="keyword">if</span>(initList(&amp;<span class="built_in">list</span>))&#123;   <span class="comment">//对其进行初始化，如果失败就直接结束</span></span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表初始化失败，无法启动程序！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来编写一下插入和删除操作，对新手来说也是比较难以理解的操作：</p><p><img src="https://s2.loli.net/2022/07/23/DdlNcI8rykQsZif.png" alt="image-20220723121423682"></p><p>我们先设计好对应的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">//list就是待操作的表，element就是需要插入的元素，index就是插入的位置（注意顺序表的index是按位序计算的，从1开始，一般都是第index个元素）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们按照上面的思路来编写一下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; i--)  <span class="comment">//先使用for循环将待插入位置后续的元素全部丢到后一位</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;    <span class="comment">//挪完之后，位置就腾出来了，直接设定即可</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;   <span class="comment">//别忘了插入之后相当于多了一个元素，记得size + 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以来测试一下了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;   <span class="comment">//编写一个函数用于打印表当前的数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;size; ++i)   <span class="comment">//表里面每个元素都拿出来打印一次</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(initList(&amp;<span class="built_in">list</span>))&#123;</span><br><span class="line">        insertList(&amp;<span class="built_in">list</span>, <span class="number">666</span>, <span class="number">1</span>);  <span class="comment">//每次插入操作后都打印一下表，看看当前的情况 </span></span><br><span class="line">        printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">        insertList(&amp;<span class="built_in">list</span>, <span class="number">777</span>, <span class="number">1</span>);</span><br><span class="line">        printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">        insertList(&amp;<span class="built_in">list</span>, <span class="number">888</span>, <span class="number">2</span>);</span><br><span class="line">        printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表初始化失败，无法启动程序！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://s2.loli.net/2022/07/23/nbSVp2yMqKlJQI6.png" alt="image-20220723153237528"></p><p>虽然这样看起来没什么问题了，但是如果我们在非法的位置插入元素会出现问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insertList(&amp;<span class="built_in">list</span>, <span class="number">666</span>, <span class="number">-1</span>);   <span class="comment">//第一个位置就是0，怎么可能插入到-1这个位置呢，这样肯定是不正确的，所以我们需要进行判断</span></span><br><span class="line">printList(&amp;<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure><p>我们需要检查一下插入的位置是否合法：</p><p><img src="https://s2.loli.net/2022/07/23/H67F1crBhqQiXxg.png" alt="image-20220723153933279"></p><p>转换成位序，也就是[1, size + 1]这个闭区间，所以我们在一开始的时候进行判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果在非法位置插入，返回0表示插入操作执行失败</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//正常情况返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以再来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(insertList(&amp;<span class="built_in">list</span>, <span class="number">666</span>, <span class="number">-1</span>))&#123;</span><br><span class="line">    printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入失败！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/23/7Q4IxSd2RDKmzBZ.png" alt="image-20220723154249242"></p><p>不过我们还是没有考虑到一个情况，那么就是如果我们的表已经装满了，也就是说size已经达到申请的内存空间最大的大小了，那么此时我们就需要考虑进行扩容了，否则就没办法插入新的元素了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="built_in">list</span>-&gt;capacity) &#123;   <span class="comment">//如果size已经到达最大的容量了，肯定是插不进了，那么此时就需要扩容了</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">list</span>-&gt;capacity + (<span class="built_in">list</span>-&gt;capacity &gt;&gt; <span class="number">1</span>);   <span class="comment">//我们先计算一下新的容量大小，这里我取1.5倍原长度，当然你们也可以想扩多少扩多少</span></span><br><span class="line">        E * newArray = <span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>, <span class="keyword">sizeof</span>(E) * newCapacity);  <span class="comment">//这里我们使用新的函数realloc重新申请更大的内存空间</span></span><br><span class="line">        <span class="keyword">if</span>(newArray == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果申请失败，那么就确实没办法插入了，只能返回0表示插入失败了</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = newArray;</span><br><span class="line">        <span class="built_in">list</span>-&gt;capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; i--)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>realloc函数可以做到控制动态内存开辟的大小，重新申请的内存空间大小就是我们指定的新的大小，并且原有的数据也会放到新申请的空间中，所以非常方便。当然如果因为内存不足之类的原因导致内存空间申请失败，那么会返回NULL，所以别忘了进行判断。</p></blockquote><p>这样，我们的插入操作就编写完善了，我们可以来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(initList(&amp;<span class="built_in">list</span>))&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i)</span><br><span class="line">            insertList(&amp;<span class="built_in">list</span>, i, i);</span><br><span class="line">        printList(&amp;<span class="built_in">list</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;顺序表初始化失败，无法启动程序！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功得到结果：</p><p><img src="https://s2.loli.net/2022/07/23/IqvG1xsUQOo5KwC.png" alt="image-20220723160222988"></p><p>这样，我们就完成了顺序表的插入操作，接着我们来编写一下删除操作，其实删除操作也比较类似，也需要对元素进行批量移动，但是我们不需要考虑扩容问题，我们先设计好函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">//list就是待操作的表，index是要删除的元素位序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照我们上面插入的思路，我们反过来想一想然后实现删除呢？首先是删除的范围：</p><p><img src="https://s2.loli.net/2022/07/23/uHBjUfKpd9ygScW.png" alt="image-20220723160901921"></p><p>换算成位序就是[1, size]这个闭区间内容，所以我们先来限定一下合法范围：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//正常情况返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是删除元素之后，我们还需要做什么呢？我们应该将删除的这个元素后面的全部元素前移一位：</p><p><img src="https://s2.loli.net/2022/07/23/dgGCcL7q9Pf41tF.png" alt="image-20220723161412178"></p><p>我们按照这个思路，来编写一下删除操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index - <span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;size - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i + <span class="number">1</span>];   <span class="comment">//实际上只需要依次把后面的元素覆盖到前一个即可</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;   <span class="comment">//最后别忘了size - 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除相比插入要简单一些，我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)  <span class="comment">//先插10个</span></span><br><span class="line">    insertList(&amp;<span class="built_in">list</span>, i, i);</span><br><span class="line">deleteList(&amp;<span class="built_in">list</span>, <span class="number">5</span>);   <span class="comment">//这里删除5号元素</span></span><br><span class="line">printList(&amp;<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure><p>成功得到结果：</p><p><img src="https://s2.loli.net/2022/07/23/q2UrtVlh1RJWKQd.png" alt="image-20220723161835205"></p><p>OK，那么插入和删除操作我们就成功完成了，还有一些比较简单的功能，我们这里也来依次实现一下，首先是获取长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;   <span class="comment">//直接返回size就完事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是按位置获取元素和查找指定元素的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E * <span class="title function_">getList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//如果超出范围就返回NULL</span></span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;size; ++i) &#123;   <span class="comment">//一直遍历，如果找到那就返回位序</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] == element) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//如果遍历完了都没找到，那么就返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的线性表就实现完成了，完整代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> * <span class="title">ArrayList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">initList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;size == <span class="built_in">list</span>-&gt;capacity) &#123;</span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">list</span>-&gt;capacity + (<span class="built_in">list</span>-&gt;capacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        E * newArray = <span class="built_in">realloc</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>, newCapacity * <span class="keyword">sizeof</span>(E));</span><br><span class="line">        <span class="keyword">if</span>(newArray == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span> = newArray;</span><br><span class="line">        <span class="built_in">list</span>-&gt;capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;size; i &gt; index - <span class="number">1</span>; --i)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = index - <span class="number">1</span>; i &lt; <span class="built_in">list</span>-&gt;size - <span class="number">1</span>; ++i)</span><br><span class="line">        <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] = <span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(ArrayList <span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E * <span class="title function_">getList</span><span class="params">(ArrayList <span class="built_in">list</span>, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span> || index &gt; <span class="built_in">list</span>-&gt;size) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(ArrayList <span class="built_in">list</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;<span class="built_in">array</span>[i] == element) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong>请问顺序实现的线性表，插入、删除、获取元素操作的时间复杂度为？</p><ul><li><strong>插入：</strong>因为要将后续所有元素都向后移动，所以平均时间复杂度为$O(n)$</li><li><strong>删除：</strong>同上，因为要将所有元素向前移动，所以平均时间复杂度为$O(n)$</li><li><strong>获取元素：</strong>因为可以利用数组特性直接通过下标访问到对应元素，所以时间复杂度为$O(1)$</li></ul><p><strong>顺序表习题：</strong></p><ol><li><p>在一个长度为<code>n</code>的顺序表中，向第<code>i</code>个元素前插入一个新的元素时，需要向后移动多少个元素？</p><p>A. <code>n - i</code>      B. <code>n - i + 1</code>     C. <code>n - i - 1</code>       D. <code>i</code></p><p><em>注意这里要求的是向第<code>i</code>个元素前插入（第<code>i</code>个表示的是位序，不是下标，不要搞混了，第1个元素下标就为0），这里我们假设<code>n</code>为3，<code>i</code>为2，那么也就是说要在下标为1的这个位置上插入元素，那么就需要移动后面的2个元素，所以答案是B</em></p></li><li><p>顺序表是一种（    ）的存储结构？</p><p>A. 随机存取        B. 顺序存取       C. 索引存取        D. 散列存取</p><p><em>首先顺序表底层是基于数组实现的，那么它肯定是支持随机访问的，因为我们可以直接使用下标想访问哪一个就访问哪一个，所以选择A，不要看到名字叫做顺序表就选择顺序存取，因为它并不需要按照顺序来进行存取，链表才是。这里也没有建立索引去访问元素，也更不可能是散列存取了，散列存取我们会在后面的哈希表中进行介绍</em></p></li></ol><hr><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>前面我们介绍了如何使用数组实现线性表，我们接着来看第二种方式，我们可以使用链表来实现，那么什么是链表呢？</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。</p><p>链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据：</p><p><img src="https://s2.loli.net/2022/07/23/gRUEfOqbtrGN2JZ.png" alt="image-20220723180221112"></p><p>而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。</p><p>那么我们就来尝试编写一个带头结点的链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;   <span class="comment">//这个还是老样子</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;   <span class="comment">//保存当前元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span>   <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">Node</span>;</span>   <span class="comment">//这里我们直接为结点指针起别名，可以直接作为表实现</span></span><br></pre></td></tr></table></figure><p>同样的，我们先将初始化函数写好：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//头结点默认下一个为NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span>   <span class="comment">//这里创建一个新的头结点，头结点不存放任何元素，只做连接，连接整个链表</span></span><br><span class="line">    initList(&amp;head);  <span class="comment">//先进行初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来设计一下链表的插入和删除，我们前面实现了顺序表的插入，那么链表的插入该怎么做呢？</p><p><img src="https://s2.loli.net/2022/07/23/71dgFSWDfoELiXB.png" alt="image-20220723175548491"></p><p>我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：</p><p><img src="https://s2.loli.net/2022/07/23/8MNURYiacWZqwu6.png" alt="image-20220723220552680"></p><p>接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：</p><p><img src="https://s2.loli.net/2022/07/23/ysETUJb6cgBz2Qx.png" alt="image-20220723175745472"></p><p>这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：</p><p><img src="https://s2.loli.net/2022/07/23/Kb7jCiWa3o4AN8D.png" alt="image-20220723175842075"></p><p>按照这个思路，我们来实现一下，首先设计一下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="comment">//head是头结点，element为待插入元素，index是待插入下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们需要先找到待插入位置的前驱结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//如果插入的位置小于1，那肯定是非法的</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;   <span class="comment">//通过--index的方式不断向后寻找前驱结点</span></span><br><span class="line">        head = head-&gt;next;   <span class="comment">//正常情况下继续向后找</span></span><br><span class="line">      <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">      <span class="comment">//如果在寻找的过程中发型已经没有后续结点了，那么说明index超出可插入的范围了，也是非法的，直接润</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环操作完成后，如果没问题那么会找到对应插入位置的前驱结点，我们只需要按照上面分析的操作来编写代码即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">      <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> ListNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//创建一个新的结点，如果内存空间申请失败返回0</span></span><br><span class="line">    node-&gt;element = element;   <span class="comment">//将元素保存到新创建的结点中</span></span><br><span class="line">    node-&gt;next = head-&gt;next;   <span class="comment">//先让新插入的节点指向原本位置上的这个结点</span></span><br><span class="line">    head-&gt;next = node;   <span class="comment">//接着将前驱结点指向新的这个结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就编写好了链表的插入操作了，我们可以来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;element);   <span class="comment">//因为头结点不存放数据，所以从第二个开始打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initList(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        insertList(&amp;head, i * <span class="number">100</span>, i);   <span class="comment">//依次插入3个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    printList(&amp;head);   <span class="comment">//打印一下看看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功得到结果：</p><p><img src="https://s2.loli.net/2022/07/23/1D94PILFxC52vRQ.png" alt="image-20220723222147977"></p><p>那么链表的插入我们研究完了，接着就是结点的删除了，那么我们如何实现删除操作呢？实际上也会更简单一些，我们可以直接将待删除节点的前驱结点指向修改为待删除节点的下一个：</p><p><img src="https://s2.loli.net/2022/07/23/N5sZx9T2a8lOzoC.png" alt="image-20220723222922058"></p><p><img src="https://s2.loli.net/2022/07/23/tNYnBJe9pczUq1Z.png" alt="image-20220723223103306"></p><p>这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了：</p><p><img src="https://s2.loli.net/2022/07/23/MFE2gZuS5eOysDW.png" alt="image-20220723223216420"></p><p>那么我们就按照这个思路来编写一下程序，首先还是设计函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">//head就是头结点，index依然是待删除的结点位序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们还是需要找到待删除结点的前驱结点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//大体和上面是一样的</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">//注意删除的范围，如果前驱结点的下一个已经是NULL了，那么也说明超过了范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是按照我们上面说的删除结点了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index--) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Node tmp = head-&gt;next;   <span class="comment">//先拿到待删除结点</span></span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;   <span class="comment">//直接让前驱结点指向下一个的下一个结点</span></span><br><span class="line">    <span class="built_in">free</span>(tmp);   <span class="comment">//最后使用free函数释放掉待删除结点的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就成功完成了链表的删除操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initList(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        insertList(&amp;head, i * <span class="number">100</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    deleteList(&amp;head, <span class="number">0</span>);   <span class="comment">//这里我们尝试删除一下第一个元素</span></span><br><span class="line">    printList(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后得到结果也是正确的：</p><p><img src="https://s2.loli.net/2022/07/23/jnOKy6ls8wAqrHJ.png" alt="image-20220723224653754"></p><p>接着就是链表的一些其他操作了，这里我们也来实现一下，首先是获取对应位置上的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E * <span class="title function_">getList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;   <span class="comment">//如果小于0那肯定不合法，返回NULL</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        head = head-&gt;next;  <span class="comment">//因为不算头结点，所以使用do-while语句</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">//如果已经超出长度那肯定也不行</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (--index);  <span class="comment">//到达index就结束</span></span><br><span class="line">    <span class="keyword">return</span> &amp;head-&gt;element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是查找对应元素的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    head = head-&gt;next;    <span class="comment">//先走到第一个结点</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;   <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;element == element) <span class="keyword">return</span> i;   <span class="comment">//如果找到，那么就返回i</span></span><br><span class="line">        head = head-&gt;next;   <span class="comment">//没找到就继续向后看</span></span><br><span class="line">        i++;   <span class="comment">//i记住要自增</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;   <span class="comment">//都已经走到链表尾部了，那么就确实没找到了，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是求链表的长度，这个太简单了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  <span class="comment">//从0开始</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;   <span class="comment">//如果下一个为NULL那就停止</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        i++;   <span class="comment">//每向后找一个就+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的链表就编写完成了，整个代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initList</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//大体和上面是一样的</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Node tmp = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E * <span class="title function_">getList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--index);</span><br><span class="line">    <span class="keyword">return</span> &amp;head-&gt;element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">findList</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;element == element) <span class="keyword">return</span> i;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sizeList</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong>请问链式实现的线性表，插入、删除、获取元素操作的时间复杂度为？</p><ul><li><strong>插入：</strong>因为要寻找对应位置的前驱结点，所以平均时间复杂度为$O(n)$，但是不需要做任何的移动操作，效率肯定是比顺序表要高的。</li><li><strong>删除：</strong>同上，所以平均时间复杂度为$O(n)$</li><li><strong>获取元素：</strong>由于必须要挨个向后寻找，才能找到对应的结点，所以时间复杂度为$O(n)$，不支持随机访问，只能顺序访问，比顺序表慢。</li></ul><p><strong>问题</strong>：什么情况下使用顺序表，什么情况下使用链表呢？</p><ul><li>通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。</li><li>而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。</li></ul><p><strong>链表练习题：</strong></p><ol><li><p>在一个长度为<code>n (n&gt;1)</code>的单链表上，设有头和尾两个指针，执行（     ）操作与链表的长度有关？</p><p>A．删除单链表中的第一个元素<br>B．删除单链表中的最后一个元素<br>C．在单链表第一个元素前插入一个新元素<br>D．在单链表最后一个元素后插入一个新元素</p><p><em>注意题干，现在有指向链表头尾的两个指针，那么A、C肯定是可以直接通过头结点找到的，无论链表长度如何都不影响，D也可以直接通过尾指针进行拼接，只有B需要尾指针的前驱结点，此时只能从头开始遍历得到，所以选择B</em></p></li><li><p>在一个单链表HL中（HL为头结点指针），若要向表头插入一个由指针p指向的结点，则执行？</p><p>A． HL＝p; p-&gt;next＝HL;<br>B． p-&gt;next＝HL; HL＝p;<br>C． p-&gt;next＝HL; p＝HL;<br>D． p-&gt;next＝HL-&gt;next; HL-&gt;next＝p;</p><p><em>既然要在表头插入一个数据，也就是说要在第一个位置插入，那么根据我们之前讲解的链表的插入，只需要将头结点指向新的结点，再让新的结点指向原本的第一个结点即可，所以选择D</em></p></li><li><p>链表不具备的特点是？</p><p>A．可随机访问任一结点             B．插入删除不需要移动元素<br>C．不必事先估计存储空间         D．所需空间与其长度成正比</p><p><em>我们前面说了，链表由于是链式存储结构，无法直接访问到对应下标的元素，所以我们只能通过遍历去找到对应位置的元素，故选择A</em></p></li></ol><hr><h3 id="双向链表和循环链表"><a href="#双向链表和循环链表" class="headerlink" title="双向链表和循环链表"></a>双向链表和循环链表</h3><p>前面我们介绍了单链表，通过这样的链式存储，我们不用再像顺序表那样一次性申请一段连续的空间，而是只需要单独为结点申请内存空间，同时在插入和删除的速度上也比顺序表轻松。不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。</p><p>为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针：</p><p><img src="https://s2.loli.net/2022/07/24/oeXm6nyW7I9lPMf.png" alt="image-20220724123947104"></p><p>这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）</p><p>这里我们也来尝试实现一下，首先定义好结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;   <span class="comment">//保存当前元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span>   <span class="comment">//指向下一个结点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">prev</span>;</span>   <span class="comment">//指向上一个结点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">Node</span>;</span></span><br></pre></td></tr></table></figure><p>接着是初始化方法，在初始化时需要将前驱和后继都设置为NULL：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    node-&gt;next = node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initNode(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是双向链表的插入操作，这就比单链表要麻烦一些了，我们先来分析一下：</p><p><img src="https://s2.loli.net/2022/07/24/MYwlVZ2fXB6icPt.png" alt="image-20220724125739857"></p><p>首先我们需要考虑后继结点，当新的结点插入之后，新的结点的后继结点就是原本在此位置上的结点，所以我们可以先将待插入结点的后继指针指向此位置上的结点：</p><p><img src="https://s2.loli.net/2022/07/24/IDYwp5gdPcSyFQO.png" alt="image-20220724130010432"></p><p>由于是双向链表，所以我们需要将原本在此位置上的结点的前驱指针指向新的结点：</p><p><img src="https://s2.loli.net/2022/07/24/5CKQ6LnzxGm4pYd.png" alt="image-20220724130219180"></p><p>接着我们来处理一下前驱结点，首先将前驱结点的后继指针修改为新的结点：</p><p><img src="https://s2.loli.net/2022/07/24/vmEViApU36FonJz.png" alt="image-20220724130342232"></p><p> 最后我们将新的结点的前驱指针指向前驱结点即可：</p><p><img src="https://s2.loli.net/2022/07/24/C65IuomOVdAaWZ8.png" alt="image-20220724130442927"></p><p>这样，我们就完成了双向链表中结点的插入操作，按照这个思路，我们来设计一下函数吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">insertList</span><span class="params">(Node head, E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//跟单链表一样，还是先找到对应的位置</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (<span class="keyword">struct</span> ListNode));  <span class="comment">//创建新的结点</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  node-&gt;element = element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next) &#123;   <span class="comment">//首先处理后继结点，现在有两种情况，一种是后继结点不存在的情况，还有一种是后继结点存在的情况</span></span><br><span class="line">        head-&gt;next-&gt;prev = node;   <span class="comment">//如果存在则修改对应的两个指针</span></span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//不存在直接将新结点的后继指针置为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head-&gt;next = node;   <span class="comment">//接着是前驱结点，直接操作就行</span></span><br><span class="line">    node-&gt;prev = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就编写好了双向链表的插入操作，来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initNode(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)  <span class="comment">//插5个元素吧</span></span><br><span class="line">        insertList(&amp;head, i * <span class="number">100</span>, i);</span><br><span class="line"></span><br><span class="line">    Node node = &amp;head;   <span class="comment">//先来正向遍历一次</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;element);</span><br><span class="line">    &#125; <span class="keyword">while</span> (node-&gt;next != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);   <span class="comment">//再来反向遍历一次</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, node-&gt;element);</span><br><span class="line">        node = node-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (node-&gt;prev != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果没有问题：</p><p><img src="https://s2.loli.net/2022/07/24/DZ7zStdGB4EsvaW.png" alt="image-20220724132205136"></p><p>无论是正向遍历还是反向遍历，都可以正常完成，相比单链表的灵活度肯定是更大的，我们接着来看删除操作，其实删除操作也是差不多的方式：</p><p><img src="https://s2.loli.net/2022/07/24/WgxjXBDAalYFGSH.png" alt="image-20220724132636580"></p><p>我们只需将前驱结点和后继结点的指向修改即可：</p><p><img src="https://s2.loli.net/2022/07/24/3aU7zV1N5Mox2Qk.png" alt="image-20220724132801105"></p><p>接着直接删除对应的结点即可：</p><p><img src="https://s2.loli.net/2022/07/24/L1zCq26k5BaGOlm.png" alt="image-20220724132906001"></p><p>现在我们就来编码吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">deleteList</span><span class="params">(Node head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//跟单链表一样，还是先找到对应的位置</span></span><br><span class="line">    <span class="keyword">while</span> (--index) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Node tmp = head-&gt;next;  <span class="comment">//先拿到待删除结点</span></span><br><span class="line">    <span class="keyword">if</span>(head-&gt;next-&gt;next) &#123;   <span class="comment">//这里有两种情况待删除结点存在后继结点或是不存在</span></span><br><span class="line">        head-&gt;next-&gt;next-&gt;prev = head;</span><br><span class="line">        head-&gt;next = head-&gt;next-&gt;next;   <span class="comment">//按照上面分析的来</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//相当于删的是最后一个结点，所以直接后继为NULL就完事</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(tmp);   <span class="comment">//最后释放已删除结点的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了双向链表的插入和删除操作，其他操作这里就不演示了。</p><p>接着我们再来简单认识一下另一种类型的链表，循环链表，这种链表实际上和前面我们讲的链表是一样的，但是它的最后一个结点，是与头结点相连的，双向链表和单向链表都可以做成这样的环形结构，我们这里以单链表为例：</p><p><img src="https://s2.loli.net/2022/07/24/KZl4SJVYQ5cfv7b.png" alt="image-20220724134153904"></p><p>这种类型的链表实际上与普通链表的唯一区别就在于最后是否连接到头结点，因此循环链表支持从任意一个结点出发都可以到达任何的结点，而普通的链表则只能从头结点出发才能到达任意结点，同样也是为了更灵活而设计的。</p><p><strong>链表练习题：</strong></p><ol><li><p>与单链表相比，双链表的优点之一是？</p><p>A．插入、删除操作更简单<br>B．可以进行随机访问<br>C．可以省略表头指针或表尾指针<br>D．顺序访问相邻结点更灵活</p><p><em>首先插入删除操作并没有更简单，反而更复杂了，随机访问肯定也是不行的，省略表头表尾指针实际上单链表也可以，所以直接冲D就完事了</em></p></li><li><p>非空的循环单链表head的尾结点（由p所指向）满足？</p><p>A．p-&gt;next &#x3D;&#x3D; NULL       B．p &#x3D;&#x3D; NULL<br>C．p-&gt;next &#x3D;&#x3D;head         D．p &#x3D;&#x3D; head</p><p><em>前面我们说了，循环链表实际上唯一区别就是尾部的下一个结点会指向头部，所以这里选择C</em></p></li><li><p>若某表最常用的操作是在最后一个结点之后插入一个结点或删除最后一个结点，则采用什么存储方式最节省运算时间？</p><p>A．单链表    B．给出表头指针的单循环链表    C．双链表      D．带头结点的双循环链表</p><p><em>题干说明了常用的是在尾结点插入或删除尾结点，那么此时不仅需要快速找到最后一个结点，也需要快速找到最后一个结点的前驱结点，所以肯定是使用双向链表，为了快速找到尾结点，使用循环双向链表从头结点直接向前就能找到，所以选择D</em></p></li><li><p>如果对线性表的操作只有两种，即删除第一个元素，在最后一个元素的后面插入新元素，则最好使用？</p><p>A．只有表头指针没有表尾指针的循环单链表<br>B．只有表尾指针没有表头指针的循环单链表<br>C．非循环双链表<br>D．循环双链表</p><p><em>首先这里需要操作两个内容，一个是删除第一个元素，另一个是在最后插入新元素，所以A的话只有表头指针虽然循环但是还是得往后遍历才行，而B正好符合，因为循环链表的尾指针可以快速到达头结点，C不可能，D的话，循环双链表也可以，但是没有单链表节省空间，故B是最优解</em></p></li></ol><hr><h2 id="特殊线性表"><a href="#特殊线性表" class="headerlink" title="特殊线性表"></a>特殊线性表</h2><p>前面我们讲解的基础的线性表，通过使用线性表，我们就可以很方便地对数据进行管理了。这一部分，我们将继续认识一些特殊的线性表，它有着特别的规则，在特定场景有着很大的作用，也是考察的重点。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：</p><p><img src="https://s2.loli.net/2022/07/24/D3heysaM9EpAgS4.png" alt="image-20220724210955622"></p><p>也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看：</p><p><img src="https://s2.loli.net/2022/07/24/2NxUpCIRLoZt9Ky.png" alt="image-20220724211442421"></p><p>底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）</p><p>实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们先使用顺序表来实现一下，这里我们需要实现两个新的操作：</p><ul><li>pop：出栈操作，从栈顶取出一个元素。</li><li>push：入栈操作，向栈中压入一个新的元素。</li></ul><p>首先还是按照我们的顺序表进行编写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">int</span> top;   <span class="comment">//这里使用top来表示当前的栈顶位置，存的是栈顶元素的下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> * <span class="title">ArrayStack</span>;</span>  <span class="comment">//起个别名</span></span><br></pre></td></tr></table></figure><p>接着我们需要编写一个初始化方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;capacity = <span class="number">10</span>;   <span class="comment">//容量还是10</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;   <span class="comment">//由于栈内没有元素，那么栈顶默认就为-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是栈的两个操作了，一个是入栈操作，一个是出栈操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>, E element)</span>&#123;</span><br><span class="line">    <span class="comment">//入栈操作只需要给元素就可以，不需要index，因为只能从尾部入栈</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于入栈只能在尾部插入，所以就很好写了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>, E element)</span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top + <span class="number">1</span>] = element;   <span class="comment">//直接设定栈顶元素</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top++;   <span class="comment">//栈顶top变量记得自增</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;| &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">stack</span>-&gt;top + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pushStack(&amp;<span class="built_in">stack</span>, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果也是正确的：</p><p><img src="https://s2.loli.net/2022/07/24/cDwAgi8FnyQBpRT.png" alt="image-20220724215755986"></p><p>可以看到，从栈底到栈顶一次是0、100、200，不过我们现在的<code>push</code>操作还不够完美，因为栈有可能塞满，所以要进行扩容处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;top + <span class="number">1</span> == <span class="built_in">stack</span>-&gt;capacity) &#123;  <span class="comment">//栈顶+1如果等于容量的话，那么说明已经塞满了</span></span><br><span class="line">        <span class="type">int</span> newCapacity = <span class="built_in">stack</span>-&gt;capacity + (<span class="built_in">stack</span>-&gt;capacity &gt;&gt; <span class="number">1</span>);   <span class="comment">//大体操作和顺序表一致</span></span><br><span class="line">        E * newArray = <span class="built_in">realloc</span>(<span class="built_in">stack</span>-&gt;<span class="built_in">array</span>, newCapacity * <span class="keyword">sizeof</span>(E));</span><br><span class="line">        <span class="keyword">if</span>(newArray == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;<span class="built_in">array</span> = newArray;</span><br><span class="line">        <span class="built_in">stack</span>-&gt;capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top + <span class="number">1</span>] = element;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们的入栈操作就编写完成了，接着是出栈操作，出栈操作我们只需要将栈顶元素取出即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(ArrayStack <span class="built_in">stack</span>)</span>&#123;   <span class="comment">//在出栈之前，我们还需要使用isEmpty判断一下栈是否为空，空栈元素都没有出个毛</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">popStack</span><span class="params">(ArrayStack <span class="built_in">stack</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;<span class="built_in">array</span>[<span class="built_in">stack</span>-&gt;top--];   <span class="comment">//直接返回栈顶元素，注意多加一个自减操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> <span class="title">stack</span>;</span></span><br><span class="line">    initStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pushStack(&amp;<span class="built_in">stack</span>, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(&amp;<span class="built_in">stack</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, popStack(&amp;<span class="built_in">stack</span>));   <span class="comment">//将栈中所有元素依次出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，出栈顺序和入栈顺序是完全相反的：</p><p><img src="https://s2.loli.net/2022/07/24/U1SrtmFs3ibGO78.png" alt="image-20220724221238281"></p><p>当然使用数组实现栈除了这种可以自己扩容的之外，也有固定大小的栈，当栈已满时，就无法再进行入栈操作了。</p><p>不过有些时候，栈的利用率可能会很低，这个时候我们可以将一个固定长度的数组共享给两个栈来使用：</p><p><img src="https://s2.loli.net/2022/07/24/HRveZ8Ed2TrtaC7.png" alt="image-20220724221917968"></p><p>数组的两头分别作为两个栈的栈底，当两个栈的栈顶指针相遇时（栈顶指针下标之差绝对值为1时），表示栈已满。通过这种方式，我们就可以将数组占用的空间更充分地使用，这样的栈我们称为<strong>共享栈</strong>。</p><p>前面我们演示了使用顺序表实现栈，我们接着来看如何使用链表来实现栈，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：</p><p><img src="https://s2.loli.net/2022/07/24/outf2S7D3WzQK8c.png" alt="image-20220724222836333"></p><p>当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initStack(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来编写一下入栈操作：</p><p><img src="https://s2.loli.net/2022/07/24/GdBj3g5YRFzSsVw.png" alt="image-20220724223550553"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));   <span class="comment">//创建新的结点</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//失败就返回0</span></span><br><span class="line">    node-&gt;next = head-&gt;next;   <span class="comment">//将当前结点的下一个设定为头结点的下一个</span></span><br><span class="line">    node-&gt;element = element;   <span class="comment">//设置元素</span></span><br><span class="line">    head-&gt;next = node;   <span class="comment">//将头结点的下一个设定为当前结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来编写一个测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;| &quot;</span>);</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (head)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, head-&gt;element);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initStack(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pushStack(&amp;head, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果没有问题：</p><p><img src="https://s2.loli.net/2022/07/24/fy6ZCNqd3eJYIrG.png" alt="image-20220724224644876"></p><p>其实出栈也是同理，所以我们只需要将第一个元素移除即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;   <span class="comment">//判断栈是否为空只需要看头结点下一个是否为NULL即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">popStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    Node top = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    E e = top-&gt;element;</span><br><span class="line">    <span class="built_in">free</span>(top);  <span class="comment">//别忘了释放结点的内存</span></span><br><span class="line">    <span class="keyword">return</span> e;   <span class="comment">//返回出栈元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initStack(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        pushStack(&amp;head, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printStack(&amp;head);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;head)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, popStack(&amp;head));   <span class="comment">//将栈中所有元素依次出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/07/24/xjOvlieXr2V9BZg.png" alt="image-20220724225005605"></p><p>实际上无论使用链表还是顺序表，都可以很轻松地实现栈，因为栈的插入和删除操作很特殊。</p><p><strong>栈练习题：</strong></p><ol><li><p>若进栈序列为1，2，3，4，则不可能得到的出栈序列是？</p><p>A.  3，2，1，4       B.  3，2，4，1<br>C.  4，2，3，1       D.  2，3，4，1</p><p><em>注意进栈并不一定会一次性全部进栈，可能会出现边进边出的情况，所以出栈的顺序可能有很多种情况，首先来看A，第一个出栈的是3，那么按照顺序，说明前面一定入栈了2、1，在出栈时4还没有入栈，然后是2、1最后是4，没有问题。接着是B，跟前面的A一样，不过这次是先出站3、2，而1留在栈中，接着4入栈，然后再让4、1出栈，也是正确的。然后是C，首先是4出栈，那么说明前三个一定都入栈了，而此时却紧接着的一定是3，而这里是2，错误。所以选择C</em></p></li><li><p>假设有5个整数以1、2、3、4、5的顺序被压入堆栈，且出栈顺序为3、5、4、2、1，那么栈大小至少为？</p><p>A.2<br>B.3<br>C.4<br>D.5</p><p><em>首先我们分析一下，第一个出栈的元素为3，那么也就是说前面的1、2都在栈内，所以大小至少为3，然后是5，那么说明此时栈内为1、2、4，算是出栈的5，那么至少需要的大小就是4了，所以选择C</em></p></li></ol><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。</p><p>就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：</p><p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。</p><p>想要实现队列也是很简单的，也可以通过两种线性表来实现，我们先来看看使用顺序表如何实现队列，假设一开始的时候队列中有0个元素，队首和队尾一般都初始都是-1这个位置：</p><p><img src="https://s2.loli.net/2022/07/25/OKVFSEfQIkDjzNu.png" alt="image-20220725110033373"></p><p>此时有新的元素入队了，队尾向后移动一格（+1），然后在所指向位置插入新的元素：</p><p><img src="https://s2.loli.net/2022/07/25/Pd6ZRUxKIhzVF9E.png" alt="image-20220725110155810"></p><p>之后都是同样的方式进行插入，队尾会一直向后移动：</p><p><img src="https://s2.loli.net/2022/07/25/8w3Mlroz25EeIcL.png" alt="image-20220725110910388"></p><p>现在我们想要执行出队操作了，那么需要将队首向后移动一格，然后删除队首指向的元素：</p><p><img src="https://s2.loli.net/2022/07/25/LaZsrtwi8AkW9gh.png" alt="image-20220725111826355"></p><p>看起来设计的还挺不错的，不过这样有一个问题，这个队列是一次性的，如果队列经过反复出队入队操作，那么最后指针会直接指向数组的最后，如果我们延长数组的话，也不是一个办法，不可能无限制的延伸下去吧？所以一般我们采用循环队列的形式，来实现重复使用一个数组（不过就没办法扩容了，大小是固定的）</p><p><img src="https://s2.loli.net/2022/07/25/MNaqpZRgkHcTlCU.png" alt="image-20220725112931675"></p><p>我们可以在移动队首队尾指针时，考虑循环的问题，也就是说如果到达了数组尽头，那么就直接从数组的前面重新开始计算，这样就相当于逻辑上都循环了，队首和队尾指针在一开始的时候都指向同一个位置，每入队一个新的元素，依然是先让队尾后移一位，在所指向位置插入元素，出队同理。</p><p>不过这样还是有问题，既然是循环的，那么怎么判断队列是否已满呢？</p><p><img src="https://s2.loli.net/2022/07/25/eptxXASywr3b4c9.png" alt="image-20220725113824587"></p><p>由于队首指针和队尾指针重合时表示队列为空，所以我们只能舍弃一个存储单元，当队尾距离队首一个单元的时候，表示队列已满。</p><p>好了，现在理论讲解完毕，我们可以开始编写代码了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    E * <span class="built_in">array</span>;</span><br><span class="line">    <span class="type">int</span> capacity;   <span class="comment">//数组容量</span></span><br><span class="line">    <span class="type">int</span> rear, front;   <span class="comment">//队尾、队首指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">ArrayQueue</span>;</span></span><br></pre></td></tr></table></figure><p>接着我们来对其进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;   <span class="comment">//默认情况下队首和队尾都指向0的位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来编写一下入队操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>, E element)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity == <span class="built_in">queue</span>-&gt;front)   <span class="comment">//先判断队列是否已满，如果队尾下一个就是队首，那么说明已满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;   <span class="comment">//队尾先向前移动一位，注意取余计算才能实现循环</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;rear] = element;   <span class="comment">//在新的位置插入元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt; &quot;</span>);</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">queue</span>-&gt;front;   <span class="comment">//遍历队列需要从队首开始</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;   <span class="comment">//先向后循环移动</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[i]);  <span class="comment">//然后打印当前位置上的元素</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (i != <span class="built_in">queue</span>-&gt;rear);   <span class="comment">//当到达队尾时，结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, i * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后结果如下：</p><p><img src="https://s2.loli.net/2022/07/25/zLRWSAH8OaTgFBv.png" alt="image-20220725143455025"></p><p>我们接着来看出队操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span>&#123;   <span class="comment">//在出队之前需要先看看容量是否足够</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;rear == <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">pollQueue</span><span class="params">(ArrayQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;   <span class="comment">//先将队首指针后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;<span class="built_in">array</span>[<span class="built_in">queue</span>-&gt;front];   <span class="comment">//出队，完事</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, i * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pollQueue(&amp;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/07/25/45dI2h7iWPuQJRp.png" alt="image-20220725144733780"></p><p>可以看到，队列是先进先出的，我们是以什么顺序放入队列中，那么出来的就是是什么顺序。</p><p>同样的，队列也可以使用链表来实现，并且使用链表的话就不需要关心容量之类的问题了，会更加灵活一些：</p><p><img src="https://s2.loli.net/2022/07/25/lwGgHXqAV5z2KNk.png" alt="image-20220725145214955"></p><p>注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。</p><p>当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位：</p><p><img src="https://s2.loli.net/2022/07/25/ufmFEwrS9xVKoIZ.png" alt="image-20220725145608827"></p><p>出队时，只需要移除队首指向的下一个元素即可：</p><p><img src="https://s2.loli.net/2022/07/25/geJRFwHKhGT69XD.png" alt="image-20220725145707707"></p><p>那么我们就按照这个思路，来编写一下代码吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    Node front, rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> * <span class="title">LinkedQueue</span>;</span>   <span class="comment">//因为要存储首位两个指针，所以这里封装一个新的结构体吧</span></span><br></pre></td></tr></table></figure><p>接着是初始化，初始化的时候，需要把头结点先创建出来：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">initQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = node;   <span class="comment">//一开始两个指针都是指向头结点的，表示队列为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是入队操作，入队其实直接在后面插入新的结点就行了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> <span class="title function_">offerQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>, E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear-&gt;next = node;   <span class="comment">//先让尾结点的下一个指向新的结点</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = node;   <span class="comment">//然后让队尾指针指向新的尾结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下看看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt; &quot;</span>);</span><br><span class="line">    Node node = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;element);  <span class="comment">//链表就简单多了，直接挨个遍历就完事</span></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://s2.loli.net/2022/07/25/SqeNUgimC4I5aZD.png" alt="image-20220725151434438"></p><p>接着是出队操作，出队操作要相对麻烦一点：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">pollQueue</span><span class="params">(LinkedQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    E e = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;element;</span><br><span class="line">    Node node = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front-&gt;next = <span class="built_in">queue</span>-&gt;front-&gt;next-&gt;next;  <span class="comment">//直接让头结点指向下下个结点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;rear == node) <span class="built_in">queue</span>-&gt;rear = <span class="built_in">queue</span>-&gt;front;   <span class="comment">//如果队尾就是待出队的结点，那么队尾回到队首位置上</span></span><br><span class="line">    <span class="built_in">free</span>(node);   <span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就编写好了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> <span class="title">queue</span>;</span></span><br><span class="line">    initQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        offerQueue(&amp;<span class="built_in">queue</span>, i*<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;<span class="built_in">queue</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pollQueue(&amp;<span class="built_in">queue</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><p><img src="https://s2.loli.net/2022/07/25/KT8mn2RkxPvgZuF.png" alt="image-20220725152020131"></p><p>效果和前面的数组实现是一样的，只不过使用链表会更加灵活一些。</p><p><strong>队列练习题：</strong></p><ol><li><p>使用链表方式存储的队列，在进行出队操作时需要？</p><p>A. 仅修改头结点指向    B. 仅修改尾指针    C. 头结点指向、尾指针都要修改    D. 头结点指向、尾指针可能都要修改</p><p><em>首先出队肯定是要动头结点指向的，但是不一定需要动尾指针，因为只有当尾指针指向的是待出队的元素时才需要，因为执行后队列就为空了，所以需要将队尾指针移回头结点处，选择D</em></p></li><li><p>引起循环队列队头位置发生变化的操作是？</p><p>A. 出队</p><p>B. 入队</p><p>C. 获取队头元素</p><p>D. 获取队尾元素</p><p><em>这个题还是很简单的，因为只有出队操作才会使得队头位置后移，所以选择A</em></p></li></ol><hr><h2 id="算法实战"><a href="#算法实战" class="headerlink" title="算法实战"></a>算法实战</h2><p>欢迎来到线性结构篇算法实战，这一部分我们将从算法相关题目上下手，解决实际问题，其中链表作为重点考察项目。</p><h3 id="（简单）删除链表中重复元素"><a href="#（简单）删除链表中重复元素" class="headerlink" title="（简单）删除链表中重复元素"></a>（简单）删除链表中重复元素</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></p><p>给定一个已排序的链表的头 head（注意是无头结点的链表，上来第一个结点就是存放第一个元素） ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表 。</p><p> 示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,1,2]<br>输出：[1,2]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,1,2,3,3]<br>输出：[1,2,3]</p></blockquote><p>这道题实际上比较简单，只是考察各位小伙伴对于链表数据结构的掌握程度，我们只需要牢牢记住如何对链表中的元素进行删除操作就能轻松解决这道题了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">deleteDuplicates</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;  <span class="comment">//首先如果进来的就是NULL，那就不用再浪费时间了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">node</span> =</span> head;  <span class="comment">//这里用一个指针来表示当前所指向的结点</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;   <span class="comment">//如果结点的下一个为空，就没必要再判断了，否则不断进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next-&gt;val == node-&gt;val) &#123;  <span class="comment">//如果下一个节点跟当前节点值一样，那么删除下一个节点</span></span><br><span class="line">            node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node-&gt;next;   <span class="comment">//否则继续从下一个节点开始向后判断</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;   <span class="comment">//最后原样返回头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（简单）反转链表"><a href="#（简单）反转链表" class="headerlink" title="（简单）反转链表"></a>（简单）反转链表</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,2]<br>输出：[2,1]</p></blockquote><p>这道题依然是考察各位小伙伴对于链表相关操作的掌握程度，我们如何才能将一个链表的顺序进行反转，关键就在于如何修改每个节点的指针指向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">newHead</span> =</span> <span class="literal">NULL</span>, * tmp;   <span class="comment">//创建一个指针存放新的头结点（注意默认要为NULL），和一个中间暂存指针</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;   <span class="comment">//这里利用head不断向后遍历，来依次修改每个结点的指向</span></span><br><span class="line">        tmp = head;   <span class="comment">//先暂存当前结点</span></span><br><span class="line">        head = head-&gt;next;  <span class="comment">//head可以先后移了</span></span><br><span class="line">        tmp-&gt;next = newHead;   <span class="comment">//将暂存节点的下一个节点，指向前一个结点</span></span><br><span class="line">        newHead = tmp;   <span class="comment">//最后新的头结点就是tmp所指向结点，这样循环操作直到结束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;  <span class="comment">//最后返回新的结点即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（中等）旋转链表"><a href="#（中等）旋转链表" class="headerlink" title="（中等）旋转链表"></a>（中等）旋转链表</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></p><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [1,2,3,4,5], k &#x3D; 2<br>输出：[4,5,1,2,3]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt="img"></p><blockquote><p>输入：head &#x3D; [0,1,2], k &#x3D; 4<br>输出：[2,0,1]</p></blockquote><p>这道题需要我们进行一些思考了，首先我们要知道，在经过旋转之后最终的头结点是哪一个，在知道后，这道题就很简单了，我们只需要断掉对应头结点的指针即可，最后返回头结点，就是旋转之后的链表了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">rotateRight</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || k == <span class="number">0</span>) <span class="keyword">return</span> head;   <span class="comment">//如果给进来的链表是空的，或者说k为0，那么就没必要再继续了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">node</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next) &#123;   <span class="comment">//先来算一波链表的长度</span></span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(k == len) <span class="keyword">return</span> head;   <span class="comment">//如果len和k长度一样，那也没必要继续了</span></span><br><span class="line">  </span><br><span class="line">    node-&gt;next = head;   <span class="comment">//将链表连起来变成循环的，一会再切割</span></span><br><span class="line">    <span class="type">int</span> index = len - k % len;  <span class="comment">//计算头结点最终位置</span></span><br><span class="line">  </span><br><span class="line">  node = head;</span><br><span class="line">    <span class="keyword">while</span> (--index) node = node-&gt;next;</span><br><span class="line">    head = node-&gt;next;    <span class="comment">//找到新的头结点</span></span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;   <span class="comment">//切断尾部与头部</span></span><br><span class="line">    <span class="keyword">return</span> head;  <span class="comment">//返回新的头结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（简单）有效的括号"><a href="#（简单）有效的括号" class="headerlink" title="（简单）有效的括号"></a>（简单）有效的括号</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><blockquote><p>输入：s &#x3D; “()”<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：s &#x3D; “()[]{}”<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：s &#x3D; “(]”<br>输出：false</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：s &#x3D; “([)]”<br>输出：false</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p>输入：s &#x3D; “{[]}”<br>输出：true </p></blockquote><p>题干很明确，就是需要我们去对这些括号完成匹配，如果给定字符串中的括号无法完成一一匹配的话，那么就表示匹配失败。实际上这种问题我们就可以利用前面学习的栈这种数据结构来解决，我们可以将所有括号的左半部分放入栈中，当遇到右半部分时，进行匹配，如果匹配失败，那么就失败，如果匹配成功，那么就消耗一个左半部分，直到括号消耗完毕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> E;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    E element;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> * <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">pushStack</span><span class="params">(Node head, E element)</span>&#123;</span><br><span class="line">    Node node = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    node-&gt;next = head-&gt;next;</span><br><span class="line">    node-&gt;element = element;</span><br><span class="line">    head-&gt;next = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isEmpty</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">E <span class="title function_">popStack</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    Node top = head-&gt;next;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    E e = top-&gt;element;</span><br><span class="line">    <span class="built_in">free</span>(top);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span>(len % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//如果长度不是偶数，那么一定不能成功匹配</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> <span class="title">head</span>;</span></span><br><span class="line">    initStack(&amp;head);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="type">char</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            pushStack(&amp;head, c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty(&amp;head)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(popStack(&amp;head) != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(popStack(&amp;head) != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(popStack(&amp;head) != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isEmpty(&amp;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般遇到括号匹配问题、算式计算问题，都可以使用栈这种数据结构来轻松解决。当然使用C语言太过原始，像Java、C++这些语言一般系统库都会直接提供栈的实现类，所以我们在打比赛时，可以尽量选择这些方便的语言，能节省不少时间。</p><h3 id="（简单）第-k-个缺失的正整数"><a href="#（简单）第-k-个缺失的正整数" class="headerlink" title="（简单）第 k 个缺失的正整数"></a>（简单）第 k 个缺失的正整数</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/kth-missing-positive-number/">1539. 第 k 个缺失的正整数</a></p><p>给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。</p><p>请你找到这个数组里第 k 个缺失的正整数。</p><p>示例 1：</p><blockquote><p>输入：arr &#x3D; [2,3,4,7,11], k &#x3D; 5<br>输出：9<br>解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,…] 。第 5 个缺失的正整数为 9 。</p></blockquote><p>示例 2：</p><blockquote><p>输入：arr &#x3D; [1,2,3,4], k &#x3D; 2<br>输出：6<br>解释：缺失的正整数包括 [5,6,7,…] 。第 2 个缺失的正整数为 6 。</p></blockquote><p>实际上这种问题，我们第一个能够想到的就是直接通过遍历挨个寻找，从头开始一个一个找，总能找到第K个吧？我们可以很轻松地得到如下的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findKthPositive</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> arrSize, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>, i = <span class="number">0</span>;   <span class="comment">//直接从第一个元素开始挨个找</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; arrSize) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] != j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(--k == <span class="number">0</span>) <span class="keyword">return</span> j;   <span class="comment">//发现不相等时，相当于找到了一个数，k自减，如果自减后为0，那么说明已经找到第K个了，直接返回对应的j</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            i++;  <span class="comment">//相等的话就继续看下一个</span></span><br><span class="line">        &#125;</span><br><span class="line">        j++;   <span class="comment">//每一轮j自增，表示下一轮应该按顺序匹配的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j + k - <span class="number">1</span>;   <span class="comment">//如果遍历完了都还没找到，那就按顺序直接算出下一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这样的效率并不高，如果这个数组特别长的话，那么我们总不可能还是挨个看吧？这样的遍历查找算法的时间复杂度为$O(n)$，那么有没有更好的算法能够解决这种问题呢？</p><p>既然这个数组是有序的，那么我们不妨直接采用二分搜索的思想，通过使用二分搜索，我们就可以更快速地找到对应的位置，但是有一个问题，我们怎么知道二分搜索找到的数，是不是第N个数呢？实际上也很简单，通过规律我们不难发现，如果某个位置上的数不匹配，那么被跳过的数<code>k</code>一定满足：<br>$$<br>k &#x3D; arr[i] - i - 1<br>$$<br>所以，我们只需要找到一个大于等于<code>k</code>的位置即可，并且要尽可能的接近，在找到之后，再根据公式去寻找即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findKthPositive</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> arrSize, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; k) <span class="keyword">return</span> k;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = arrSize;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] - mid - <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k - (arr[l - <span class="number">1</span>] - (l - <span class="number">1</span>) - <span class="number">1</span>) + arr[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此文章为搬运！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/post/4a17b156.html"/>
    <id>http://yoursite.com/post/4a17b156.html</id>
    <published>2022-11-11T09:22:13.396Z</published>
    <updated>2022-11-11T09:50:03.856Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
</feed>
